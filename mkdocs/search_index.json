{
    "docs": [
        {
            "location": "/", 
            "text": "Go-Smart Simulation Framework\n\n\nPrimary authors\n : \nNUMA Engineering Services Ltd\n (NUMA), Dundalk, Ireland\n\n\nProject website\n : \nhttp://www.gosmart-project.eu/\n\n\nThis project is co-funded by the European Commission under grant agreement no. 600641.\n\n\nThe GSSF tool provides the necessary scripts and libraries to run a simulation workflow beginning from STL and VTP surfaces, configuring a \nCGAL\n-based tool for volumetric meshing, running \nElmer\n for finite element simulation, and ending with a \nVTK\n-extracted isosurface.\n\n\nIntroduction\n\n\nThe simulation framework (as opposed to the \nGSSA\n architecture) is a single specific\nworkflow that allows a user to provide a set of STL surfaces and Elmer\nconfiguration, and get back a lesion surface.\n\n\nThis workflow is based primarily on \nElmer FEM\n,\na Finite Element multiphysics package primarily developed by\n\nCSC\n in Finland, and \nCGAL\n, a\ncomputational geometry library primarily developed by\n\nGeometryFactory\n in France.\nWe thank the developers of both projects\nfor their feedback and input on Elmer and CGAL related questions. Other\ncomponents depend on \nGMSH\n, \nVTK\n and\n\nPythonOCC\n.\n\n\nNon-GSSF workflow options include\nDocker-defined workflows. These may partially overlap, for example, by using the\nGSSF CGAL meshing tools to provide a volumetric mesh before launching an in-Docker\nworkflow. This is the point you could perhaps substitute a Taverna workflow, for\nthose more familiar with it.\n\n\nGSSF itself consists of a series of semi-optional steps based on a GSSF-XML\nconfiguration file. This file is actually fairly similar to the GSSA-XML, but\nmore case-specific to the workflow. For instance, it will have mesher\nconfiguration indicating which surfaces the CGAL mesher should include. GSSA\ncontains a module for compiling GSSA-XML to GSSF-XML, if possible.\n\n\nIt is entirely reasonable to use GSSF separately from the rest of the GSSA\narchitecture, starting with a GSSF-XML settings file and appropriately laid out\ndirectory. This is especially useful for offline debugging of simulation\nsettings, which you may (or may not) want to update in the\n\nCDM\n later,\nbut, in general, provides a simple workflow for taking STL surfaces, producing a\nvolumetric mesh, running an Elmer simulation and returning a clean STL\nisosurface. Moreover, it is scriptable using fairly flexible command-line\narguments, and terminal output is nicely colour-coded.\n\n\nExecution of the workflow is managed by \ngo-smart-launcher\n.\n\n\nWorkflow\n\n\nThe workflow follows the illustrated steps. It executes (in order), the \nNeedle\nLibrary\n, the \nmeshers\n, the \nmesh\noptimizer\n, \nElmerGrid\n, the \nsolver\n then\n\nlesion extraction\n on the results. It may also, if configured, run\n\nvalidation\n.\n\n\n\n\nDirectory layout\n\n\nOn start-up of \ngo-smart-launcher\n, GSSF is given a GSSF-XML file.\nConventionally, this is named \nsettings.xml\n and placed in the working directory\nwith all input STL files in a subfolder \ninput\n.\n\n\ninput/\nsettings.xml\n\n\n\nAs the workflow progresses, separate directories are created for each component\n(possibly multiple for certain components).\n\n\ninput/\nelmer/\nelmergrid/\n...\nlesion/\nlogger/\noutput/\nvalidation/\nsettings.xml\n\n\n\nThe final output STL surface should appear in the \noutput\n folder prior to\nsuccessful exit. The \nlogs\n for all components are, by default, kept in the\n\nlogger\n directory.\n\n\nImprovements\n\n\n\n\nThis should be run as part of a normal Docker workflow, rather than as a\n  special case\n\n\nThe use of \nlogger\n as a singleton should be minimized", 
            "title": "Home"
        }, 
        {
            "location": "/#go-smart-simulation-framework", 
            "text": "Primary authors  :  NUMA Engineering Services Ltd  (NUMA), Dundalk, Ireland  Project website  :  http://www.gosmart-project.eu/  This project is co-funded by the European Commission under grant agreement no. 600641.  The GSSF tool provides the necessary scripts and libraries to run a simulation workflow beginning from STL and VTP surfaces, configuring a  CGAL -based tool for volumetric meshing, running  Elmer  for finite element simulation, and ending with a  VTK -extracted isosurface.", 
            "title": "Go-Smart Simulation Framework"
        }, 
        {
            "location": "/#introduction", 
            "text": "The simulation framework (as opposed to the  GSSA  architecture) is a single specific\nworkflow that allows a user to provide a set of STL surfaces and Elmer\nconfiguration, and get back a lesion surface.  This workflow is based primarily on  Elmer FEM ,\na Finite Element multiphysics package primarily developed by CSC  in Finland, and  CGAL , a\ncomputational geometry library primarily developed by GeometryFactory  in France.\nWe thank the developers of both projects\nfor their feedback and input on Elmer and CGAL related questions. Other\ncomponents depend on  GMSH ,  VTK  and PythonOCC .  Non-GSSF workflow options include\nDocker-defined workflows. These may partially overlap, for example, by using the\nGSSF CGAL meshing tools to provide a volumetric mesh before launching an in-Docker\nworkflow. This is the point you could perhaps substitute a Taverna workflow, for\nthose more familiar with it.  GSSF itself consists of a series of semi-optional steps based on a GSSF-XML\nconfiguration file. This file is actually fairly similar to the GSSA-XML, but\nmore case-specific to the workflow. For instance, it will have mesher\nconfiguration indicating which surfaces the CGAL mesher should include. GSSA\ncontains a module for compiling GSSA-XML to GSSF-XML, if possible.  It is entirely reasonable to use GSSF separately from the rest of the GSSA\narchitecture, starting with a GSSF-XML settings file and appropriately laid out\ndirectory. This is especially useful for offline debugging of simulation\nsettings, which you may (or may not) want to update in the CDM  later,\nbut, in general, provides a simple workflow for taking STL surfaces, producing a\nvolumetric mesh, running an Elmer simulation and returning a clean STL\nisosurface. Moreover, it is scriptable using fairly flexible command-line\narguments, and terminal output is nicely colour-coded.  Execution of the workflow is managed by  go-smart-launcher .", 
            "title": "Introduction"
        }, 
        {
            "location": "/#workflow", 
            "text": "The workflow follows the illustrated steps. It executes (in order), the  Needle\nLibrary , the  meshers , the  mesh\noptimizer ,  ElmerGrid , the  solver  then lesion extraction  on the results. It may also, if configured, run validation .", 
            "title": "Workflow"
        }, 
        {
            "location": "/#directory-layout", 
            "text": "On start-up of  go-smart-launcher , GSSF is given a GSSF-XML file.\nConventionally, this is named  settings.xml  and placed in the working directory\nwith all input STL files in a subfolder  input .  input/\nsettings.xml  As the workflow progresses, separate directories are created for each component\n(possibly multiple for certain components).  input/\nelmer/\nelmergrid/\n...\nlesion/\nlogger/\noutput/\nvalidation/\nsettings.xml  The final output STL surface should appear in the  output  folder prior to\nsuccessful exit. The  logs  for all components are, by default, kept in the logger  directory.", 
            "title": "Directory layout"
        }, 
        {
            "location": "/#improvements", 
            "text": "This should be run as part of a normal Docker workflow, rather than as a\n  special case  The use of  logger  as a singleton should be minimized", 
            "title": "Improvements"
        }, 
        {
            "location": "/go-smart-launcher/", 
            "text": "Go-Smart Simulation Framework - Launcher script (go-smart-launcher)\n\n\nCommand line usage\n\n\nWrapper for Go-Smart simulation environment. This is the usual entry point to\nGSSF and is invoked by the GSSA server with when used inside the architecture.\nIt may, however, be used standalone from the command-line.\n\n\ngo-smart-launcher [-h] [--elmer ELMER_BINARY]\n                  [--elmer-logfile OUTFILENAME] [--logfile-addpid]\n                  [--silent] [--debug] [--nprocs NPROCS] [--only ONLY]\n                  [--black-and-white] [--leavetree]\n                  [--cwd GLOBAL_WORKING_DIRECTORY]\n                  [--status-socket UPDATE_STATUS]\n                  configfilenames\n                  ...\n\n\n\n\nPositional arguments\n\n\n\n\n\n\n\n\nArgument\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nconfigfilenames\n\n\nLocations of configuration file (latter override former)\n\n\n\n\n\n\n\n\nOptional arguments\n\n\n\n\n\n\n\n\nArgument\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n-h, --help\n\n\nshow this help message and exit\n\n\n\n\n\n\n--elmer ELMER_BINARY\n\n\nname of the ElmerSolver binary\n\n\n\n\n\n\n--elmer-logfile OUTFILENAME\n\n\nname of the ElmerSolver binary\n\n\n\n\n\n\n--logfile-addpid\n\n\nwhether the PID should be appended to the given\n\n\n\n\n\n\n\n\nlogfile name\n\n\n\n\n\n\n--silent\n\n\nprevent wrapper output\n\n\n\n\n\n\n--debug\n\n\nadditional, debug output (overridden by --silent)\n\n\n\n\n\n\n--nprocs NPROCS\n\n\nnumber of processes to start\n\n\n\n\n\n\n--only ONLY\n\n\nonly execute a single component\n\n\n\n\n\n\n--black-and-white\n\n\nforce colorama off\n\n\n\n\n\n\n--leavetree\n\n\ndo not touch the mesh filetree in Elmer\n\n\n\n\n\n\n--cwd GLOBAL_WORKING_DIRECTORY\n\n\noverride working directory as root of simulation\n\n\n\n\n\n\n--status-socket UPDATE_STATUS\n\n\nlocation of socket to which to write status", 
            "title": "go-smart-launcher"
        }, 
        {
            "location": "/go-smart-launcher/#go-smart-simulation-framework-launcher-script-go-smart-launcher", 
            "text": "", 
            "title": "Go-Smart Simulation Framework - Launcher script (go-smart-launcher)"
        }, 
        {
            "location": "/go-smart-launcher/#command-line-usage", 
            "text": "Wrapper for Go-Smart simulation environment. This is the usual entry point to\nGSSF and is invoked by the GSSA server with when used inside the architecture.\nIt may, however, be used standalone from the command-line.  go-smart-launcher [-h] [--elmer ELMER_BINARY]\n                  [--elmer-logfile OUTFILENAME] [--logfile-addpid]\n                  [--silent] [--debug] [--nprocs NPROCS] [--only ONLY]\n                  [--black-and-white] [--leavetree]\n                  [--cwd GLOBAL_WORKING_DIRECTORY]\n                  [--status-socket UPDATE_STATUS]\n                  configfilenames\n                  ...  Positional arguments     Argument  Description      configfilenames  Locations of configuration file (latter override former)     Optional arguments     Argument  Description      -h, --help  show this help message and exit    --elmer ELMER_BINARY  name of the ElmerSolver binary    --elmer-logfile OUTFILENAME  name of the ElmerSolver binary    --logfile-addpid  whether the PID should be appended to the given     logfile name    --silent  prevent wrapper output    --debug  additional, debug output (overridden by --silent)    --nprocs NPROCS  number of processes to start    --only ONLY  only execute a single component    --black-and-white  force colorama off    --leavetree  do not touch the mesh filetree in Elmer    --cwd GLOBAL_WORKING_DIRECTORY  override working directory as root of simulation    --status-socket UPDATE_STATUS  location of socket to which to write status", 
            "title": "Command line usage"
        }, 
        {
            "location": "/xml/", 
            "text": "GSSF XML Configuration Format (GSSF-XML)\n\n\nGSSF-XML is the workflow-specific configuration for a simulation. Along with\nany STL input files, it is sufficient to run a simulation.\n\n\nNote that this\nis distinct from the (workflow-independent) GSSA-XML format\n. A processor, compiling\nGSSA-XML to GSSF-XML is included in GSSA. The workflow-specific nature of\nGSSF-XML gives it a distinctive character. A few sections are similar to the\nGSSA-XML definition, in that they define over-arching problem characteristics\n(such as geometry), but in GSSF-XML, each component of the workflow also has a\nseparate section with its own configuration.\n\n\nFormat\n\n\nThis describes the general format of a GSSF-XML file.\n\n\ngosmart [ debug=\"DEBUG:bool\" ] [ version=\"GSSF_XML_VERSION:0.1.0\" ] [ name=\"RUNNAME\" ]\n\n      \ngeometry\n\n        \ncentre x=\"CX\" y=\"CY\" z=\"CZ\" /\n\n        \nneedleaxis x=\"NX\" y=\"NY\" z=\"NZ\" /\n\n        \nsimulationscaling ratio=\"SCALING\" /\n\n      \n/geometry\n\n      \nregions\n\n        \nsurface|zone|both name=\"REGIONNAME\" input=\"INPUTLOCATION\" groups=\"GROUP1; GROUP2;...\" /\n\n        ...\n      \n/regions\n\n      \nconstants\n\n        \nconstant name=\"PARAMNAME\" value=\"PARAMVALUE\" type=\"PARAMTYPE\" /\n\n        ...\n      \n/constants\n\n    [ \nneedles\n\n        \nneedle name=\"NEEDLEID\"\n\n          [ \nparameters\n\n              \nparameter name=\"PARAMNAME\" value=\"PARAMVALUE\" type=\"PARAMTYPE\" /\n\n              ...\n            \n/parameters\n ]\n        \n/needle\n\n        ...\n      \n/needles\n ]\n    [ \nneedlelibrary\n\n        \n!-- see 'Needle Library Component' --\n\n      \n/needlelibrary\n ]\n    [ \nmesher\n\n        \n!-- see 'Meshing Components' --\n\n      \n/mesher\n ]\n    [ \noptimizer\n\n        \n!-- see 'Optimizer Component' --\n\n      \n/optimizer\n ]\n    [ \nelmergrid\n\n        \n!-- see 'ElmerGrid Component' --\n\n      \n/elmergrid\n ]\n    [ \nelmer\n\n        \n!-- see 'ElmerSolver Component' --\n\n      \n/elmer\n ]\n    [ \nlesion\n\n        \n!-- see 'Lesion Component' --\n\n      \n/lesion\n ]\n    [ \nvalidation\n\n        \n!-- see 'Validation Component' --\n\n      \n/validation\n ]\n\n/gosmart\n\n\n\n\nThe XML version is given by \nGSSF_XML_VERSION\n. The latest version, described\nhere, is \n0.1.0\n. Note European spelling of \ncentre\n.\n\n\nXML Schema\n\n\nThis is a \nTODO\n. For the moment, the documentation here should be adequate\nto perform basic creation and manipulation of GSSF-XML.\nHowever, in keeping with the increasing importance of\nDocker-workflow and the presence of an automatic GSSA-XML \n GSSF-XML\ngenerator, this is secondary to the GSSA-XML formalization.", 
            "title": "GSSF XML Format"
        }, 
        {
            "location": "/xml/#gssf-xml-configuration-format-gssf-xml", 
            "text": "GSSF-XML is the workflow-specific configuration for a simulation. Along with\nany STL input files, it is sufficient to run a simulation.  Note that this\nis distinct from the (workflow-independent) GSSA-XML format . A processor, compiling\nGSSA-XML to GSSF-XML is included in GSSA. The workflow-specific nature of\nGSSF-XML gives it a distinctive character. A few sections are similar to the\nGSSA-XML definition, in that they define over-arching problem characteristics\n(such as geometry), but in GSSF-XML, each component of the workflow also has a\nseparate section with its own configuration.", 
            "title": "GSSF XML Configuration Format (GSSF-XML)"
        }, 
        {
            "location": "/xml/#format", 
            "text": "This describes the general format of a GSSF-XML file.  gosmart [ debug=\"DEBUG:bool\" ] [ version=\"GSSF_XML_VERSION:0.1.0\" ] [ name=\"RUNNAME\" ] \n       geometry \n         centre x=\"CX\" y=\"CY\" z=\"CZ\" / \n         needleaxis x=\"NX\" y=\"NY\" z=\"NZ\" / \n         simulationscaling ratio=\"SCALING\" / \n       /geometry \n       regions \n         surface|zone|both name=\"REGIONNAME\" input=\"INPUTLOCATION\" groups=\"GROUP1; GROUP2;...\" / \n        ...\n       /regions \n       constants \n         constant name=\"PARAMNAME\" value=\"PARAMVALUE\" type=\"PARAMTYPE\" / \n        ...\n       /constants \n    [  needles \n         needle name=\"NEEDLEID\" \n          [  parameters \n               parameter name=\"PARAMNAME\" value=\"PARAMVALUE\" type=\"PARAMTYPE\" / \n              ...\n             /parameters  ]\n         /needle \n        ...\n       /needles  ]\n    [  needlelibrary \n         !-- see 'Needle Library Component' -- \n       /needlelibrary  ]\n    [  mesher \n         !-- see 'Meshing Components' -- \n       /mesher  ]\n    [  optimizer \n         !-- see 'Optimizer Component' -- \n       /optimizer  ]\n    [  elmergrid \n         !-- see 'ElmerGrid Component' -- \n       /elmergrid  ]\n    [  elmer \n         !-- see 'ElmerSolver Component' -- \n       /elmer  ]\n    [  lesion \n         !-- see 'Lesion Component' -- \n       /lesion  ]\n    [  validation \n         !-- see 'Validation Component' -- \n       /validation  ] /gosmart   The XML version is given by  GSSF_XML_VERSION . The latest version, described\nhere, is  0.1.0 . Note European spelling of  centre .", 
            "title": "Format"
        }, 
        {
            "location": "/xml/#xml-schema", 
            "text": "This is a  TODO . For the moment, the documentation here should be adequate\nto perform basic creation and manipulation of GSSF-XML.\nHowever, in keeping with the increasing importance of\nDocker-workflow and the presence of an automatic GSSA-XML   GSSF-XML\ngenerator, this is secondary to the GSSA-XML formalization.", 
            "title": "XML Schema"
        }, 
        {
            "location": "/family/", 
            "text": "Go-Smart Simulation Framework Family in GSSA\n\n\nGSSA \nfamilies\n prepare configuration for running a solver, in\nthis case GSSF. This is in the form of a Python class extending\n\ngssa.family.Family\n. There are actually two components comprising the GSSF\nFamily.\n\n\nElmer-libnuma\n\n\nThis refers to Elmer run in conjunction with some\n\nNUMA\n-written libraries, and more generally to GSSF, which\nis centred around this pairing.\n\n\nMesherGSSFMixin\n\n\nThis is a mixin, used in GSSF and elsewhere for setting up a volumetric mesh\nusing \nGSSF-XML\n. In the Elmer-libnuma case, it only prepares the\nrelevant part of the XML file, which is completed and run by the Elmer-libnuma\nfamily. In other cases, the volumetric entries only are used and run by\n\ngo-smart-launcher\n, before whichever component into which\nthis is mixed in takes the output MSH file for its own simulation.\n\n\nParameters used\n\n\n\n\n\n\n\n\nParameter name\n\n\nDescription (effect on output GSSF-XML)\n\n\n\n\n\n\n\n\n\n\nNEEDLE_TIP_LOCATION\n\n\nUsed to find the offset for each needle. If the \nCENTRE_LOCATION\n has not been provided, this is used to provide the \ngeometry\n centre\n\n\n\n\n\n\nNEEDLE_ENTRY_LOCATION\n\n\nWith each needle tip, this is used to find the needle axis and the first needle is used to provide the \ngeometry\n section's \nneedleaxis\n\n\n\n\n\n\nNEEDLE_ACTIVE_LENGTH\n\n\nSize of active length sphere for specific needle, as used in the \nactive\n section in the relevant \nmesher\n section \nneedle\n\n\n\n\n\n\nSETTING_SOLID_NEEDLES\n\n\nIndicates that all needle geometries should be meshed solidly, prompting the \nzones\n attribute of \nneedlelibrary\n and \nzone_boundaries\n of \nmesher\n to be set\n\n\n\n\n\n\nCONSTANT_GLOBAL_ACTIVE_LENGTH\n\n\nSize of default active length, to be used in the \nactive\n section in the relevant \nmesher\n section \nneedle\n\n\n\n\n\n\nCENTRE_LOCATION\n\n\nDefault \ngeometry\n centre in GSSF-XML. May be a JSON float triple or \nfirst-needle\n (to use tip of first needle) or \ncentroid-of-tips\n to calculate the combined centre of all needle tips\n\n\n\n\n\n\nCENTRE_OFFSET\n\n\nThis adds an offset to the \ngeometry\n centre, without altering the needle location\n\n\n\n\n\n\nSIMULATION_SCALING\n\n\nBecomes the \ngeometry\n section \nsimulationscaling\n\n\n\n\n\n\nSETTING_ORGAN_AS_SUBDOMAIN\n\n\nSwitches the \norgan\n from an \norgan\n in the \nmesher\n to a \nzone\n\n\n\n\n\n\nSETTING_AXISYMMETRIC_INNER\n\n\nAdds an \ninner\n to the \nmesher\n of the given template\n\n\n\n\n\n\nSETTING_AXISYMMETRIC_INNER_COARSE\n\n\nAdds a coarse \ninner\n to the \nmesher\n of the given template\n\n\n\n\n\n\nSIMULATION_DOMAIN_RADIUS\n\n\nGives a bounding radius for use in the \nmesher\n section \nextent\n\n\n\n\n\n\nRESOLUTION_HIGH\n\n\nTriggers an approximately double resolution set of characteristic length parameters compared to the default\n\n\n\n\n\n\nRESOLUTION_FIELD_NEAR\n, \nRESOLUTION_FIELD_FAR\n, \nRESOLUTION_FIELD_ZONE\n, \nRESOLUTION_FIELD_NEEDLE_ZONE\n\n\nOverride specific characteristic length field parameters in the \nmesher\n section", 
            "title": "Family in GSSA"
        }, 
        {
            "location": "/family/#go-smart-simulation-framework-family-in-gssa", 
            "text": "GSSA  families  prepare configuration for running a solver, in\nthis case GSSF. This is in the form of a Python class extending gssa.family.Family . There are actually two components comprising the GSSF\nFamily.", 
            "title": "Go-Smart Simulation Framework Family in GSSA"
        }, 
        {
            "location": "/family/#elmer-libnuma", 
            "text": "This refers to Elmer run in conjunction with some NUMA -written libraries, and more generally to GSSF, which\nis centred around this pairing.", 
            "title": "Elmer-libnuma"
        }, 
        {
            "location": "/family/#meshergssfmixin", 
            "text": "This is a mixin, used in GSSF and elsewhere for setting up a volumetric mesh\nusing  GSSF-XML . In the Elmer-libnuma case, it only prepares the\nrelevant part of the XML file, which is completed and run by the Elmer-libnuma\nfamily. In other cases, the volumetric entries only are used and run by go-smart-launcher , before whichever component into which\nthis is mixed in takes the output MSH file for its own simulation.  Parameters used     Parameter name  Description (effect on output GSSF-XML)      NEEDLE_TIP_LOCATION  Used to find the offset for each needle. If the  CENTRE_LOCATION  has not been provided, this is used to provide the  geometry  centre    NEEDLE_ENTRY_LOCATION  With each needle tip, this is used to find the needle axis and the first needle is used to provide the  geometry  section's  needleaxis    NEEDLE_ACTIVE_LENGTH  Size of active length sphere for specific needle, as used in the  active  section in the relevant  mesher  section  needle    SETTING_SOLID_NEEDLES  Indicates that all needle geometries should be meshed solidly, prompting the  zones  attribute of  needlelibrary  and  zone_boundaries  of  mesher  to be set    CONSTANT_GLOBAL_ACTIVE_LENGTH  Size of default active length, to be used in the  active  section in the relevant  mesher  section  needle    CENTRE_LOCATION  Default  geometry  centre in GSSF-XML. May be a JSON float triple or  first-needle  (to use tip of first needle) or  centroid-of-tips  to calculate the combined centre of all needle tips    CENTRE_OFFSET  This adds an offset to the  geometry  centre, without altering the needle location    SIMULATION_SCALING  Becomes the  geometry  section  simulationscaling    SETTING_ORGAN_AS_SUBDOMAIN  Switches the  organ  from an  organ  in the  mesher  to a  zone    SETTING_AXISYMMETRIC_INNER  Adds an  inner  to the  mesher  of the given template    SETTING_AXISYMMETRIC_INNER_COARSE  Adds a coarse  inner  to the  mesher  of the given template    SIMULATION_DOMAIN_RADIUS  Gives a bounding radius for use in the  mesher  section  extent    RESOLUTION_HIGH  Triggers an approximately double resolution set of characteristic length parameters compared to the default    RESOLUTION_FIELD_NEAR ,  RESOLUTION_FIELD_FAR ,  RESOLUTION_FIELD_ZONE ,  RESOLUTION_FIELD_NEEDLE_ZONE  Override specific characteristic length field parameters in the  mesher  section", 
            "title": "MesherGSSFMixin"
        }, 
        {
            "location": "/logging/", 
            "text": "Logging \n Errors in GSSF\n\n\nLogging tools\n\n\nStatistics monitoring\n\n\nGSSF has prototypal integration with\n\nvigilant\n, a tool that maintains a\ndatastore monitoring all instances of (in our case)\n\ngo-smart-launcher\n. It can do so across\nmultiple machines and provides a web-based interface for viewing. Note that this\nis entirely distinct from GSSA, which orchestrates workflows such as GSSF, and\nis unaware of vigilant monitoring.\n\n\nNote that \nvigilant\n has changed name during the Go-Smart project, from\n\nobservant\n. This name is often used in the code and will be replaced as the\ndependencies are updated. However, as the project is currently \nvigilant\n, and\nseems to be going forward, the comments generally use this name to refer to it.\n\n\nMonitoring can be configured using the YAML file\n\n{INSTALLROOT}/etc/gosmart/vigilant.cfg\n. Configuration options are as described\nin the \nvigilant\n documentation.\n\n\nTODO\n: Update configuration format to JSON, following upstream change.\n\n\nFIXME\n: Posting vigilant messages on \nlog_line\n is currently suspended,\nas the filling pipe was slowing the rest of the master process. While this needs to be\nfarmed out to a thread properly, for the moment test this functionality by\nuncommenting the marked line in logger_vigilant.py.\n\n\nLogpick\n\n\nThe logpick functionality allows individual components of the GSSF workflow to\nmonitor their child process output for certain regular expressions, indicating\nthe start and end of some internal process. The GoSmartComponent class, on which\nall the components are based, will sum the time spent in this internal task\n(based on the child's output) and print the total when the subprocess exits. The\nlogpick entries are expressed as a triple in \nGoSmartComponent.logpick_pairs\n:\n\n\n(\"START_PATTERN\", \"END_PATTERN\", \"LABEL\")\n\n\n\nFor example, in the Elmer solver:\n\n\n(\"CRS_IncompleteLU: ILU(0) (Real), Starting Factorization\", \"ComputeChange:\", \"Solver A\")\n\n\n\ngives, when the solver finally exits,\n\n\nTimings (sec resolution):\n --    9 Solver A \n'CRS_IncompleteLU: ILU(0) (Real), Starting Factorization' - 'ComputeChange:'\n\n --  486 [other]\n    ====   \n -- 496\n\n\n\nAdding additional logpick entries will, naturally, help account for more of the\ntime used.\n\n\nRate limiting\n\n\nEach component has a member \nsuppress_logging_over_per_second\n, which may be\nset to a maximum number of log lines per second from that component or \nNone\n\nto be disabled.\n\n\nError handling\n\n\nException classes\n\n\nVery basic unified error types are provided, to help distinguish between user\nerrors, programmer errors, modeller errors and errors of unknown responsibility.\n\n\nThese contain codes which can be matched by the client-side tools. In theory,\nall errors returned from GSSF will be one of these. Any\nerrors thrown beneath will be caught and wrapped accordingly.\n\n\n\n\n\n\n\n\nError Code\n\n\nError ID\n\n\nIntepretation\n\n\nGSSF exception class (if app.)\n\n\n\n\n\n\n\n\n\n\nSUCCESS\n\n\n0\n\n\nAll worked\n\n\n-\n\n\n\n\n\n\nE_UNKNOWN\n\n\n1\n\n\nError of unknown origin\n\n\nGoSmartError\n\n\n\n\n\n\nE_CLIENT\n\n\n2\n\n\nTriggered by an issue on the client side, such as illogical input\n\n\nGoSmartClientError\n\n\n\n\n\n\nE_SERVER\n\n\n3\n\n\nProblems with the server or server-side tools\n\n\nGoSmartServerError\n\n\n\n\n\n\nE_MODEL\n\n\n4\n\n\nModelling problem, where the server cannot complete the task for physical/mathematical/numerical/syntactical reasons that are the responsibility of the model developer\n\n\nGoSmartModelError\n\n\n\n\n\n\n\n\nIn general, we err on the side of caution and attribute anything uncertain to\n\nE_SERVER\n or \nE_UNKNOWN\n. However, it may be, in the future, that being less\nconservative with \nE_MODEL\n will help provide automatic feedback on issues.\n\n\nIdeally, in GSSF all errors thrown should be one of the classes listed above,\nfound in \ngssf.errors\n. These will be caught by\n\ngo-smart-launcher\n and an error file written that GSSA\ncan process and report accordingly. If using GSSF standalone, this will still\nwork properly.\n\n\nError regexes\n\n\nEach line is checked for a per-component error regex, and stored as the\nsubprocess error message if it occurs. Since the subprocess may know nothing\nabout GSSF, such an approach is required to ensure we can provide some feedback,\nat least, if it crashes.", 
            "title": "Logging &amp; Errors"
        }, 
        {
            "location": "/logging/#logging-errors-in-gssf", 
            "text": "", 
            "title": "Logging &amp; Errors in GSSF"
        }, 
        {
            "location": "/logging/#logging-tools", 
            "text": "Statistics monitoring  GSSF has prototypal integration with vigilant , a tool that maintains a\ndatastore monitoring all instances of (in our case) go-smart-launcher . It can do so across\nmultiple machines and provides a web-based interface for viewing. Note that this\nis entirely distinct from GSSA, which orchestrates workflows such as GSSF, and\nis unaware of vigilant monitoring.  Note that  vigilant  has changed name during the Go-Smart project, from observant . This name is often used in the code and will be replaced as the\ndependencies are updated. However, as the project is currently  vigilant , and\nseems to be going forward, the comments generally use this name to refer to it.  Monitoring can be configured using the YAML file {INSTALLROOT}/etc/gosmart/vigilant.cfg . Configuration options are as described\nin the  vigilant  documentation.  TODO : Update configuration format to JSON, following upstream change.  FIXME : Posting vigilant messages on  log_line  is currently suspended,\nas the filling pipe was slowing the rest of the master process. While this needs to be\nfarmed out to a thread properly, for the moment test this functionality by\nuncommenting the marked line in logger_vigilant.py.  Logpick  The logpick functionality allows individual components of the GSSF workflow to\nmonitor their child process output for certain regular expressions, indicating\nthe start and end of some internal process. The GoSmartComponent class, on which\nall the components are based, will sum the time spent in this internal task\n(based on the child's output) and print the total when the subprocess exits. The\nlogpick entries are expressed as a triple in  GoSmartComponent.logpick_pairs :  (\"START_PATTERN\", \"END_PATTERN\", \"LABEL\")  For example, in the Elmer solver:  (\"CRS_IncompleteLU: ILU(0) (Real), Starting Factorization\", \"ComputeChange:\", \"Solver A\")  gives, when the solver finally exits,  Timings (sec resolution):\n --    9 Solver A  'CRS_IncompleteLU: ILU(0) (Real), Starting Factorization' - 'ComputeChange:' \n --  486 [other]\n    ====   \n -- 496  Adding additional logpick entries will, naturally, help account for more of the\ntime used.  Rate limiting  Each component has a member  suppress_logging_over_per_second , which may be\nset to a maximum number of log lines per second from that component or  None \nto be disabled.", 
            "title": "Logging tools"
        }, 
        {
            "location": "/logging/#error-handling", 
            "text": "Exception classes  Very basic unified error types are provided, to help distinguish between user\nerrors, programmer errors, modeller errors and errors of unknown responsibility.  These contain codes which can be matched by the client-side tools. In theory,\nall errors returned from GSSF will be one of these. Any\nerrors thrown beneath will be caught and wrapped accordingly.     Error Code  Error ID  Intepretation  GSSF exception class (if app.)      SUCCESS  0  All worked  -    E_UNKNOWN  1  Error of unknown origin  GoSmartError    E_CLIENT  2  Triggered by an issue on the client side, such as illogical input  GoSmartClientError    E_SERVER  3  Problems with the server or server-side tools  GoSmartServerError    E_MODEL  4  Modelling problem, where the server cannot complete the task for physical/mathematical/numerical/syntactical reasons that are the responsibility of the model developer  GoSmartModelError     In general, we err on the side of caution and attribute anything uncertain to E_SERVER  or  E_UNKNOWN . However, it may be, in the future, that being less\nconservative with  E_MODEL  will help provide automatic feedback on issues.  Ideally, in GSSF all errors thrown should be one of the classes listed above,\nfound in  gssf.errors . These will be caught by go-smart-launcher  and an error file written that GSSA\ncan process and report accordingly. If using GSSF standalone, this will still\nwork properly.  Error regexes  Each line is checked for a per-component error regex, and stored as the\nsubprocess error message if it occurs. Since the subprocess may know nothing\nabout GSSF, such an approach is required to ensure we can provide some feedback,\nat least, if it crashes.", 
            "title": "Error handling"
        }, 
        {
            "location": "/constants/", 
            "text": "Constants in GSSF\n\n\nIn GSSF code, parameters are generally referred to as \nconstants\n, which is not\nentirely accurate (TODO), but reflects the fact that the definition itself does\nnot usually change throughout the simulation. They are generally\nfloats/ints/etc. but may be MATC functions that are dropped into the SIF at the\nstart of the simulation.\n\n\nConstants in GSSF mostly arise from the parameters set in the GSSF-XML, but\ninclude other values such as the mesh scaling, which is not (in GSSF) in the\nparameter section. They are also used to transfer certain values between\ncomponents, where one calculates and adds a constant to the global space and\nanother uses it.\n\n\nParameters in the Elmer SIF template\n\n\nThe \nSIF template\n is a\n\nJinja2\n template. As such, Python parameter\ndictionaries are used to pass parameters into the template. These are named \np\n\nand \nneedles\n, being the global and needle-specific parameters, respectively. The\nneedle parameter dictionary, \nneedles\n, is a dictionary of parameter dictionaries,\nindexed as integers based on the needle indexes from the GSSF-XML.\n\n\nThe parameter dictionaries are of class \nParameterDict\n, which extends Python's\n\ndict\n built-in. In particular, these can be used with the member syntax:\n\np.CONSTANT_BODY_TEMPERATURE\n, for example, will return the relevant \nParameter\n\nobject for that parameter. This actually covers all global constants, not just\nthe GSSF parameters, so a few extra items are available. For instance,\n\np.NEEDLE_AXIS_SCALE_X\n will return the scaling in the \nx\n direction used by the\nneedle library.\n\n\nThe \nParameter\n class, to which the returned parameters belong, is castable to\nfloat, int and string. The Jinja filter \ntyped\n will cause it to be output with\nits SIF type as a prefix (useful, for example, when assigning to a property in\nthe SIF file). If not otherwise cast, it will appear as a string representation.\nIf the parameter type is an array, it will be converted to a space separated\nlist.\n\n\nFor instance, if the following line appears in the SIF template:\n\n\n...\nPower = {{ p.CONSTANT_INPUT_POWER|typed }}\n...\n\n\n\nand the parameter in the GSSF-XML is:\n\n\nconstant name=\"CONSTANT_INPUT_POWER\" value=\"140.0\" type=\"float\" /\n\n\n\n\nthe rendered SIF will be:\n\n\n...\nPower = Real 140.0\n...\n\n\n\nwhereas, if the parameter in the GSSF-XML is:\n\n\nconstant name=\"CONSTANT_INPUT_POWER\" value=\"[140.0, 200.0, 120.0]\" type=\"array(float)\" /\n\n\n\n\nthe rendered SIF will be:\n\n\n...\nPower = Real 140.0 200.0 120.0\n...\n\n\n\nNote that this does not take care of the need to supply an index count to the\npower list. A conditional may be needed.", 
            "title": "Constants"
        }, 
        {
            "location": "/constants/#constants-in-gssf", 
            "text": "In GSSF code, parameters are generally referred to as  constants , which is not\nentirely accurate (TODO), but reflects the fact that the definition itself does\nnot usually change throughout the simulation. They are generally\nfloats/ints/etc. but may be MATC functions that are dropped into the SIF at the\nstart of the simulation.  Constants in GSSF mostly arise from the parameters set in the GSSF-XML, but\ninclude other values such as the mesh scaling, which is not (in GSSF) in the\nparameter section. They are also used to transfer certain values between\ncomponents, where one calculates and adds a constant to the global space and\nanother uses it.", 
            "title": "Constants in GSSF"
        }, 
        {
            "location": "/constants/#parameters-in-the-elmer-sif-template", 
            "text": "The  SIF template  is a Jinja2  template. As such, Python parameter\ndictionaries are used to pass parameters into the template. These are named  p \nand  needles , being the global and needle-specific parameters, respectively. The\nneedle parameter dictionary,  needles , is a dictionary of parameter dictionaries,\nindexed as integers based on the needle indexes from the GSSF-XML.  The parameter dictionaries are of class  ParameterDict , which extends Python's dict  built-in. In particular, these can be used with the member syntax: p.CONSTANT_BODY_TEMPERATURE , for example, will return the relevant  Parameter \nobject for that parameter. This actually covers all global constants, not just\nthe GSSF parameters, so a few extra items are available. For instance, p.NEEDLE_AXIS_SCALE_X  will return the scaling in the  x  direction used by the\nneedle library.  The  Parameter  class, to which the returned parameters belong, is castable to\nfloat, int and string. The Jinja filter  typed  will cause it to be output with\nits SIF type as a prefix (useful, for example, when assigning to a property in\nthe SIF file). If not otherwise cast, it will appear as a string representation.\nIf the parameter type is an array, it will be converted to a space separated\nlist.  For instance, if the following line appears in the SIF template:  ...\nPower = {{ p.CONSTANT_INPUT_POWER|typed }}\n...  and the parameter in the GSSF-XML is:  constant name=\"CONSTANT_INPUT_POWER\" value=\"140.0\" type=\"float\" /   the rendered SIF will be:  ...\nPower = Real 140.0\n...  whereas, if the parameter in the GSSF-XML is:  constant name=\"CONSTANT_INPUT_POWER\" value=\"[140.0, 200.0, 120.0]\" type=\"array(float)\" /   the rendered SIF will be:  ...\nPower = Real 140.0 200.0 120.0\n...  Note that this does not take care of the need to supply an index count to the\npower list. A conditional may be needed.", 
            "title": "Parameters in the Elmer SIF template"
        }, 
        {
            "location": "/regions/", 
            "text": "Regions and Geometry in GSSF\n\n\nGeometry\n\n\nA specific simulation workflow has certain overarching geometrical information.\nThese are provided in the \ngeometry\n section of the \nGSSF-XML\n file.\nIn particular, there are:\n\n\n\n\n\n\n\n\nProperty (Type)\n\n\nEntry in \ngeometry\n dictionary\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nCentre \n(x, y, z)\n\n\ncentre\n\n\nFocal point of the simulation. Often a needle tip. Other locations generally expressed as an offset from this location. Default centre of simulation extent\n\n\n\n\n\n\nNeedle axis \n(x, y, z)\n\n\nneedleaxis\n\n\nPrimary/default axis for the simulation. May or may not be an actual axis of a needle, but will be used as a fallback if a needle axis is not provided.\n\n\n\n\n\n\nSimulation scaling factor \n(r)\n\n\nsimulationscaling\n\n\nThe (multiplicative) ratio going from input surface length scales (e.g. mm) to simulation length scales (e.g. m)\n\n\n\n\n\n\n\n\nThese may be referred to, and assumed to exist, in any component.\n\n\nRegions\n\n\nRegions are geometric entities. They may be either 2D subdomains (boundary\nsubdomains) or 3D subdomains. They are specified in the \nGSSF-XML\n by\none of the three tags:\n\n\n    \nsurface name=\nREGIONNAME\n input=\nINPUTLOCATION\n groups=\nGROUP1; GROUP2;...\n /\n\n    \nzone name=\nREGIONNAME\n input=\nINPUTLOCATION\n groups=\nGROUP1; GROUP2;...\n /\n\n    \nboth name=\nREGIONNAME\n input=\nINPUTLOCATION\n groups=\nGROUP1; GROUP2;...\n /\n\n\n\n\n\nThe \nREGIONNAME\n may be any string used to refer to the region elsewhere in the\nconfiguration (such as the \nmesher\n) and the \nINPUTLOCATION\n is\nusually the filename of the STL surface defining the region. This may be given\nrelative to the working directory. Generally, STL files are kept in an \ninput/\n\nsubdirectory.\n\n\nThe \nNeedle Library\n may add regions representing needles, as\n\nNEEDLE_[NEEDLEID]\n (and \nNEEDLE_[NEEDLEID]_ACTIVE\n,\n\nNEEDLE_[NEEDLEID]_INACTIVE\n if appropriate).\n\n\nLabelling\n\n\nRegions will be labelled by integers in the final mesh, which are used in the\nElmer SIF file to assign properties, boundary conditions and so forth. The\nrelationship between labels and regions is hard to predict if possible at all,\nas it is dependent on the volumetric meshing, number of subdomains appearing in\nthe simulation domain and ordering of assignment.\n\n\nAs such, the \nparameter dictionary\n accessible in the SIF template\ncontains region entries. For example:\n\n\nregions\n\n  \nsurface name=\"organ\" input... /\n\n  ...\n\n\n\nis used in the SIF template as follows:\n\n\n!===================\nBoundary Condition 3\n!===================\nTarget Boundary = Integer {{ p.REGION_ORGAN }}\nTemperature = {{ p.CONSTANT_BODY_TEMPERATURE|typed }}\n...\n\n\n\nThe conversion from region name to corresponding constant name uses\n\nslugify\n.\n\n\nGroups\n\n\nAs several regions can all effectively represent the same subdomain, or related\nsubdomains, \ngroups\n allow you to indicate this in GSSF-XML. This is by far the\nmore common way to include mesh indexes in the SIF template, as it future proofs\nagainst multiple related region entries, even if you currently only use one.\n\n\nGroups are notated, for example:\n\n\nsurface name=\"organ\" input=\"input/organ.stl\" groups=\"organs; outer-surfaces\" /\n\n\n\n\nIn this case, entries \nBOUNDARIES_ORGANS\n and \nBOUNDARIES_OUTER_SURFACES\n will\nbe created in the global parameter dictionary. These actually include the whole\ntarget boundary line in the SIF file, so if they are not present, the line is\nomitted and no syntax error occurs.\n\n\n!===================\nBoundary Condition 3\n!===================\n{{ p.BOUNDARIES_ORGANS }}\nTemperature = {{ p.CONSTANT_BODY_TEMPERATURE|typed }}\n...\n\n\n\nSimilarly, this is true for the needles in their parameter dictionaries, with\n\nneedles[id].BOUNDARIES_NEEDLE_ACTIVE\n and \nneedles[id].BOUNDARIES_NEEDLE_INACTIVE\n.", 
            "title": "Regions &amp; Geometry"
        }, 
        {
            "location": "/regions/#regions-and-geometry-in-gssf", 
            "text": "", 
            "title": "Regions and Geometry in GSSF"
        }, 
        {
            "location": "/regions/#geometry", 
            "text": "A specific simulation workflow has certain overarching geometrical information.\nThese are provided in the  geometry  section of the  GSSF-XML  file.\nIn particular, there are:     Property (Type)  Entry in  geometry  dictionary  Description      Centre  (x, y, z)  centre  Focal point of the simulation. Often a needle tip. Other locations generally expressed as an offset from this location. Default centre of simulation extent    Needle axis  (x, y, z)  needleaxis  Primary/default axis for the simulation. May or may not be an actual axis of a needle, but will be used as a fallback if a needle axis is not provided.    Simulation scaling factor  (r)  simulationscaling  The (multiplicative) ratio going from input surface length scales (e.g. mm) to simulation length scales (e.g. m)     These may be referred to, and assumed to exist, in any component.", 
            "title": "Geometry"
        }, 
        {
            "location": "/regions/#regions", 
            "text": "Regions are geometric entities. They may be either 2D subdomains (boundary\nsubdomains) or 3D subdomains. They are specified in the  GSSF-XML  by\none of the three tags:       surface name= REGIONNAME  input= INPUTLOCATION  groups= GROUP1; GROUP2;...  / \n     zone name= REGIONNAME  input= INPUTLOCATION  groups= GROUP1; GROUP2;...  / \n     both name= REGIONNAME  input= INPUTLOCATION  groups= GROUP1; GROUP2;...  /   The  REGIONNAME  may be any string used to refer to the region elsewhere in the\nconfiguration (such as the  mesher ) and the  INPUTLOCATION  is\nusually the filename of the STL surface defining the region. This may be given\nrelative to the working directory. Generally, STL files are kept in an  input/ \nsubdirectory.  The  Needle Library  may add regions representing needles, as NEEDLE_[NEEDLEID]  (and  NEEDLE_[NEEDLEID]_ACTIVE , NEEDLE_[NEEDLEID]_INACTIVE  if appropriate).  Labelling  Regions will be labelled by integers in the final mesh, which are used in the\nElmer SIF file to assign properties, boundary conditions and so forth. The\nrelationship between labels and regions is hard to predict if possible at all,\nas it is dependent on the volumetric meshing, number of subdomains appearing in\nthe simulation domain and ordering of assignment.  As such, the  parameter dictionary  accessible in the SIF template\ncontains region entries. For example:  regions \n   surface name=\"organ\" input... / \n  ...  is used in the SIF template as follows:  !===================\nBoundary Condition 3\n!===================\nTarget Boundary = Integer {{ p.REGION_ORGAN }}\nTemperature = {{ p.CONSTANT_BODY_TEMPERATURE|typed }}\n...  The conversion from region name to corresponding constant name uses slugify .  Groups  As several regions can all effectively represent the same subdomain, or related\nsubdomains,  groups  allow you to indicate this in GSSF-XML. This is by far the\nmore common way to include mesh indexes in the SIF template, as it future proofs\nagainst multiple related region entries, even if you currently only use one.  Groups are notated, for example:  surface name=\"organ\" input=\"input/organ.stl\" groups=\"organs; outer-surfaces\" /   In this case, entries  BOUNDARIES_ORGANS  and  BOUNDARIES_OUTER_SURFACES  will\nbe created in the global parameter dictionary. These actually include the whole\ntarget boundary line in the SIF file, so if they are not present, the line is\nomitted and no syntax error occurs.  !===================\nBoundary Condition 3\n!===================\n{{ p.BOUNDARIES_ORGANS }}\nTemperature = {{ p.CONSTANT_BODY_TEMPERATURE|typed }}\n...  Similarly, this is true for the needles in their parameter dictionaries, with needles[id].BOUNDARIES_NEEDLE_ACTIVE  and  needles[id].BOUNDARIES_NEEDLE_INACTIVE .", 
            "title": "Regions"
        }, 
        {
            "location": "/utilities/", 
            "text": "Utility Functions in GSSF\n\n\nThere are several helper functions used in GSSF that may be of use if you are\nextending or modifying behaviour. While these are underscore prefixed, this may\nbe changed later - however, they are intended for use within the gssf.*\nspace.\n\n\ngenerate_rotation_matrix\n\n\nLocation\n: \ngssf.globals._generate_rotation_matrix(x, y, z, backward=False)\n,\n\n_generate_numpy_rotation_matrix(x, y, z, backward=False, rx=0, ry=1, rz=0)\n\n\nThe \nNumpy\n version of this function creates a rotation\n\nmatrix\n\ntaking the vector \n(rx, ry, rz)\n to \n(x, y, z)\n, rotating about an axis\nperpendicular to both. The \nbackward\n argument allows for easy reversal of the\nrotation. The algorithm used is \nRodrigues' rotation\nformula\n.\nThe non-Numpy version renders the matrix as a SIF-embeddedable space-separated\nlist.\n\n\nThis utility is especially useful for translating needles from reference\ncoordinates to the embedded location and for moving backwards and forwards between\nan axisymmetric problem and its 3D embedding. Note that reference needles in the\nGSSF library are aligned to \n(0, 0, 1)\n, not \n(0, 1, 0)\n. However, library\naxisymmetric meshes lie in this plane. \nExtensions\n to the mesh\ninterpolation functionality in Elmer allow\n\n\nslugify\n\n\nLocation\n: \ngssf.globals.slugify(inp)\n\n\nThis is a workaround for lack of a Python3 slugify early in the project, and is\nto be replaced with a real slugify (e.g.\n\npython-slugify\n). It is documented\nhere solely because any differences between our (very basic, 4-line) behaviour\nand an upstream slugify's needs to be considered before swapping.\n\n\nIt uppercases input, removes any parentheses and replaces dash and space with an\nunderscore. For example:\n\n\n\"Electric conductivity (tissue)\" ----\n ELECTRIC_CONDUCTIVITY_TISSUE\n\n\n\nThis is normally seen in generation of constant names for the parameter\ndictionaries in the SIF template.", 
            "title": "Utilities"
        }, 
        {
            "location": "/utilities/#utility-functions-in-gssf", 
            "text": "There are several helper functions used in GSSF that may be of use if you are\nextending or modifying behaviour. While these are underscore prefixed, this may\nbe changed later - however, they are intended for use within the gssf.*\nspace.", 
            "title": "Utility Functions in GSSF"
        }, 
        {
            "location": "/utilities/#generate_rotation_matrix", 
            "text": "Location :  gssf.globals._generate_rotation_matrix(x, y, z, backward=False) , _generate_numpy_rotation_matrix(x, y, z, backward=False, rx=0, ry=1, rz=0)  The  Numpy  version of this function creates a rotation matrix \ntaking the vector  (rx, ry, rz)  to  (x, y, z) , rotating about an axis\nperpendicular to both. The  backward  argument allows for easy reversal of the\nrotation. The algorithm used is  Rodrigues' rotation\nformula .\nThe non-Numpy version renders the matrix as a SIF-embeddedable space-separated\nlist.  This utility is especially useful for translating needles from reference\ncoordinates to the embedded location and for moving backwards and forwards between\nan axisymmetric problem and its 3D embedding. Note that reference needles in the\nGSSF library are aligned to  (0, 0, 1) , not  (0, 1, 0) . However, library\naxisymmetric meshes lie in this plane.  Extensions  to the mesh\ninterpolation functionality in Elmer allow", 
            "title": "generate_rotation_matrix"
        }, 
        {
            "location": "/utilities/#slugify", 
            "text": "Location :  gssf.globals.slugify(inp)  This is a workaround for lack of a Python3 slugify early in the project, and is\nto be replaced with a real slugify (e.g. python-slugify ). It is documented\nhere solely because any differences between our (very basic, 4-line) behaviour\nand an upstream slugify's needs to be considered before swapping.  It uppercases input, removes any parentheses and replaces dash and space with an\nunderscore. For example:  \"Electric conductivity (tissue)\" ----  ELECTRIC_CONDUCTIVITY_TISSUE  This is normally seen in generation of constant names for the parameter\ndictionaries in the SIF template.", 
            "title": "slugify"
        }, 
        {
            "location": "/components/needle-library/", 
            "text": "Go-Smart Needle Library - STEP manipulation and geometry generation\n\n\nThis tool uses \nPythonOCC\n to generate triangulated\nsurfaces from STEP files, for representing needles and other features. It uses\nPythonOCC also for geometric transformation, allowing a single reference STEP to\nbe placed into a mesh in any location or of any scaling.\n\n\nWith the appropriate GSSA-XML extensions, this will allow a user to provide\ntheir own STEP geometry as the definition of a surface or surfaces in the mesh.\nThe present implementation provides some support for splitting an STEP file,\nwith the first listed component being output as an 'active' part, the second as\nan 'inactive' part, both in STL format.\n\n\ngo-smart-needle-library\n\n\nManagement tool for Go-Smart ablation needle geometry library\n\n\ngo-smart-needle-library [-h] [--logfile LOGFILENAME] [--logfile-addpid]\n                           [--silent] [--debug] [--output OUTFILE]\n                           [--output-extent EXTENTFILE]\n                           ...\n\n\n\nPositional arguments\n\n\n\n\n\n\n\n\nArgument\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nconfigfilenames\n\n\nLocations of configuration file (latter override former)\n\n\n\n\n\n\n\n\nOptional arguments\n\n\n\n\n\n\n\n\nArgument\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n-h, --help\n\n\nshow this help message and exit\n\n\n\n\n\n\n--logfile LOGFILENAME\n\n\nname of the log file\n\n\n\n\n\n\n--logfile-addpid\n\n\nwhether the PID should be appended to the given\n\n\n\n\n\n\n\n\nlogfile name\n\n\n\n\n\n\n--silent\n\n\nprevent wrapper output\n\n\n\n\n\n\n--debug\n\n\nadditional, debug output (overridden by --silent)\n\n\n\n\n\n\n--output OUTFILE\n\n\ndestination STL file for needle\n\n\n\n\n\n\n--output-extent EXTENTFILE\n\n\ndestination STL file for extent\n\n\n\n\n\n\n\n\nNeedle CAD geometries\n\n\nThese should lie along the z-axis, with tip at the origin and be in STEP format.\nOne or two roots (shapes) may exist. If two, the STEP will be split into two STL\nsurfaces, with the first marked as the 'active' surface, the second as the\n'inactive'. Interpretation is left to the modelling components of the workflow.\nIf multiple shapes are provided, they should be output in STLs suffixed by the\nordinal position in the STEP (1 \n n). This should work for n \n 2 but has\nnot been fully tested.\n\n\nGSSF component\n\n\nThe corresponding GSSF component forms a fairly transparent wrapper for\n\ngo-smart-needle-library\n.\n\n\nConfiguration\n\n\nThe second-level \nGSSF-XML\n tag is as follows:\n\n\n    \nneedlelibrary [ skip=\nBOOL:false\n ]\n\n        \nneedle id=\nID\n [ name=\nNAME\n ] [ axis=\nAX AY AZ\n ] [ offset=\nOX OY OZ\n ]/\n\n      [ \ntarget x=\nTX\n y=\nTY\n z=\nTZ\n /\n ]\n      [ \nextent x=\nTX\n y=\nTY\n z=\nTZ\n /\n ]\n    \n/needlelibrary\n\n\n\n\n\nThe \nid\n is the library name of the required template. It is recommended to\nwrite this as \nid=\"stock:ID\"\n for future compatibility. The name is a human\nreadable name to use to refer to this needle elsewhere in the simulation. If not\nprovided, the ordinal index of the \nneedle\n node will be used. The \naxis\n\noverrides the global \naxis\n from the \ngeometry\n section of [GSSF-XML][xml.md]\nfor this needle. The \noffset\n indicates the offset of this needle from the\ntarget of the needle-set, by default the geometry centre.\n\n\nThe \ntarget\n allows the user to specify an offset of the needle-set from the\ncentre of simulation as defined in the \ngeometry\n section.\nThe \nextent\n, if provided, instructs the \nneedlelibrary\n to generate an STL\nsimulation boundary. This may be intersected later with the organ boundary to\ngenerate an outer boundary of the simulation domain.", 
            "title": "Needle Library Component"
        }, 
        {
            "location": "/components/needle-library/#go-smart-needle-library-step-manipulation-and-geometry-generation", 
            "text": "This tool uses  PythonOCC  to generate triangulated\nsurfaces from STEP files, for representing needles and other features. It uses\nPythonOCC also for geometric transformation, allowing a single reference STEP to\nbe placed into a mesh in any location or of any scaling.  With the appropriate GSSA-XML extensions, this will allow a user to provide\ntheir own STEP geometry as the definition of a surface or surfaces in the mesh.\nThe present implementation provides some support for splitting an STEP file,\nwith the first listed component being output as an 'active' part, the second as\nan 'inactive' part, both in STL format.", 
            "title": "Go-Smart Needle Library - STEP manipulation and geometry generation"
        }, 
        {
            "location": "/components/needle-library/#go-smart-needle-library", 
            "text": "Management tool for Go-Smart ablation needle geometry library  go-smart-needle-library [-h] [--logfile LOGFILENAME] [--logfile-addpid]\n                           [--silent] [--debug] [--output OUTFILE]\n                           [--output-extent EXTENTFILE]\n                           ...  Positional arguments     Argument  Description      configfilenames  Locations of configuration file (latter override former)     Optional arguments     Argument  Description      -h, --help  show this help message and exit    --logfile LOGFILENAME  name of the log file    --logfile-addpid  whether the PID should be appended to the given     logfile name    --silent  prevent wrapper output    --debug  additional, debug output (overridden by --silent)    --output OUTFILE  destination STL file for needle    --output-extent EXTENTFILE  destination STL file for extent", 
            "title": "go-smart-needle-library"
        }, 
        {
            "location": "/components/needle-library/#needle-cad-geometries", 
            "text": "These should lie along the z-axis, with tip at the origin and be in STEP format.\nOne or two roots (shapes) may exist. If two, the STEP will be split into two STL\nsurfaces, with the first marked as the 'active' surface, the second as the\n'inactive'. Interpretation is left to the modelling components of the workflow.\nIf multiple shapes are provided, they should be output in STLs suffixed by the\nordinal position in the STEP (1   n). This should work for n   2 but has\nnot been fully tested.", 
            "title": "Needle CAD geometries"
        }, 
        {
            "location": "/components/needle-library/#gssf-component", 
            "text": "The corresponding GSSF component forms a fairly transparent wrapper for go-smart-needle-library .  Configuration  The second-level  GSSF-XML  tag is as follows:       needlelibrary [ skip= BOOL:false  ] \n         needle id= ID  [ name= NAME  ] [ axis= AX AY AZ  ] [ offset= OX OY OZ  ]/ \n      [  target x= TX  y= TY  z= TZ  /  ]\n      [  extent x= TX  y= TY  z= TZ  /  ]\n     /needlelibrary   The  id  is the library name of the required template. It is recommended to\nwrite this as  id=\"stock:ID\"  for future compatibility. The name is a human\nreadable name to use to refer to this needle elsewhere in the simulation. If not\nprovided, the ordinal index of the  needle  node will be used. The  axis \noverrides the global  axis  from the  geometry  section of [GSSF-XML][xml.md]\nfor this needle. The  offset  indicates the offset of this needle from the\ntarget of the needle-set, by default the geometry centre.  The  target  allows the user to specify an offset of the needle-set from the\ncentre of simulation as defined in the  geometry  section.\nThe  extent , if provided, instructs the  needlelibrary  to generate an STL\nsimulation boundary. This may be intersected later with the organ boundary to\ngenerate an outer boundary of the simulation domain.", 
            "title": "GSSF component"
        }, 
        {
            "location": "/components/mesher/", 
            "text": "Meshing Components in GSSF\n\n\nThese wrap the two primary meshing tools in GSSF: \nmesher-cgal\n and\n\nGMSH\n. This gives rise to two (current) subclasses of\n\nGoSmartMesher\n, each providing a component class: \n3D-CGAL\n and\n\n2D-GMSH\n. The specific type of component is specified using\nthe \ntype\n parameter in the XML.\n\n\nWhile most applications will use a single volumetric mesh, in certain cases it\nmay be necessary to use more than one mesh. Both (or more) will then be\navailable to the SIF template. Particular applications are: a highly detailed\nvolumetric mesh geometrically embedded in a simplified outer mesh; an\naxisymmetric mesh representing a portion of a larger Cartesian problem.\n\n\nAt least at present, meshing components are expected to output an MSH file. This\nmakes linkage more straightforward to the \nElmerGrid\n component.\n\n\nConfiguration\n\n\nThe relevant second-level element in GSSF-XML is:\n\n\n    \nmesher [ skip=\nSKIP:false\n ] type=\n(CGAL|axisymmetric)\n\n        [ \ninner type=\n(CGAL|axisymmetric)\n name=\nINNERNAME\n template=\nTEMPLATE\n\n                 [ region=\nINNERREGION\n ] [ needle=\n(inner_only|outer_only|both):both\n ]\n\n              \n!-- see CGAL/axisymmetric-specific sections --\n\n          \n/inner\n ]\n          \n!-- see CGAL/axisymmetric-specific sections --\n\n    \n/mesher\n\n\n\n\n\nAs a workaround for incomplete re-use of existing 2D meshes, \nSKIP\n may be\n\nouter\n instead of a boolean, to re-use an existing primary 3D mesh, but\nregenerate any inner (usu. 2D) meshes. In the case that there are no inner\nmeshes (most cases), this is equivalent to \ntrue\n.\n\n\nThe \ninner\n parameter \ntemplate\n, allows you to specify the template used for\nthe inner mesh - this is normally an axisymmetric needle geometry from the GSSF\nlibrary. The \nneedle\n attribute allows you to indicate in which mesh the needle\nshould be embedded, (although axisymmetric templates may not always adjust for\nthis parameter). The \nINNERREGION\n allows you to specify a \nregion\n\nthat should form an outer boundary for the inner mesh - this is currently implemented\nonly in the case of volumetric meshes, but strictly it could be extended to both.\n\n\nTODO\n: Allow user-supplied inner templates. Account for multiple needles when\nusing inner meshes.\n\n\n3D-CGAL\n\n\nThis is a component wrapping \nmesher-cgal\n.\n\n\nConfiguration\n\n\nThis is configured, extending the \nmesher\n or \ninner\n sections, as follows:\n\n\n   \nmesher|inner zone_boundaries=\nBOOL:false\n\n     \n!-- as in general configuration then --\n\n       \nlengthscales nearfield=\nNF\n farfield=\nFF\n [ zonefield=\nZF:(float|'ignore')\n ]\n                     [ needlezonefield=\nNZF\n ] [ granularity=\nGRANULARITY:float\n ]\n                     [ vessels=\n(near|far)\n ] [ needles=\nnear\n ] [ zones=\nsolid\n ]\n                     [ zone_radius=\nZONERADIUS:float\n ] /\n\n     ( \nextent radius=\nEXTENTRADIUS\n /\n | \nextent region=\nREGIONNAME\n /\n )\n     [ \ncentre x=\nCX\n y=\nCY\n z=\nCZ\n radius=\nCR\n /\n ]\n       \nzone|needle region=\nREGIONNAME\n [ characteristic_length=\nZCL\n ] [ priority=\nZP\n ]\n\n         [ \nactivity x=\nAX\n y=\nAY\n z=\nAZ\n r=\nAR\n /\n ]\n       \n/zone|needle\n\n       ...\n     [ \norgan region=\nREGIONNAME\n/\n ]\n       \nsurface region=\nREGIONNAME\n/\n\n       ...\n   \n/mesher|inner\n\n\n\n\n\nThe \nsurface\n is any boundary region (was previously \nvessel\n) and requires only\nthe name of the \nregion\n as expressed in the \nregions\n section. All\nglobal discretization information is contained in the lengthscales tag, which\nprovides parameters for the characteristic length field. The \nextent\n may be\nsupplied as a radius about the \ncentre\n or as a region. The \norgan\n, which is\nintersected with the \nextent\n, may be supplied separately as a region. Needles,\nif simply surfaces, only need a \nREGIONNAME\n but if a zone, or both, may use the\nextended zone attribute set.\n\n\nZones have, at least, a \nREGIONNAME\n but they may also have their own\ncharacteristic length field and priority, which indicates which zones obscure\nwhich in an overlap. Optionally, there may be a child \nactivity\n node,\nspecifying a sphere of activity. The inactive region will be added as a new\nregion to the global regions map.\n\n\n2D-GMSH\n\n\nGMSH\n is used to mesh 2D domains, primarily for use in\naxisymmetric problems.\n\n\nConfiguration\n\n\nThis is configured, extending the \nmesher\n or \ninner\n sections, as follows:\n\n\n   \nmesher|inner\n\n     \n!-- as in general configuration then --\n\n     \ntemplate name=\nTEMPLATENAME\n height=\nHEIGHT\n width=\nWIDTH\n\n        \ndimension name=\nDIMENSIONNAME\n value=\nDIMENSIONVALUE:float\n /\n\n     \n/template\n\n     \nlengthscales nearfield=\nNEARFIELD\n farfield=\nFARFIELD\n /\n\n   \n/mesher|inner\n\n\n\n\n\nThe \nTEMPLATENAME\n parameter indicates a library template to use (effectively a\nGMSH \n.geo\n template). The template may use \n$CONSTANT_XYZ\n to refer to\ndimension \nXYZ\n and \n$INNERHEIGHT\n or \n$INNERWIDTH\n to refer to \nHEIGHT\n or\n\nWIDTH\n, respectively. It may use \n$NEARFIELD\n and \n$FARFIELD\n to get the\n\nNEARFIELD\n and \nFARFIELD\n parameters, which should together be sufficient to\nset the characteristic lengths for GMSH. The template also has access to the\n\nregion\n IDs, which is prior to renumbering, but allows multiple\nmesher components to number consistently. These use the same constant naming\nscheme as the \nElmer\n SIF template (\nREGION_ORGAN\n, etc.). To parse\nthe template,\n\nstring.Template\n\nis used.\n\n\nTODO\n: Confirm this has no axisymmetric-specific behaviour and rename it to\nGMSH. Add support for supplied (non-library) templates.\n\n\nRenumbering\n\n\nFor Elmer to process a SIF file, numbering of bodies (volumetric subdomains)\nmust be contiguous. We use a application-level routine,\n\nGSSF.renumber_bodies(msh_files)\n, to achieve this,\nafter all other preliminary steps have been performed and we know exactly\nwhich subdomains appear in the simulation mesh. After this,\n\nElmerGrid\n is applied to convert to Elmer's meshing format. The output of\nthis step, not itself a full component, is in \nmeshes-reordered/\n. Other than\nnumbering, these meshes should match those output by the optimizer in \noptimizer/\n.\n\n\nTODO\n: to renumber in two steps, the mesh indices are temporarily replaced with\ncharacters using an ASCII mapping. This creates an artifical restriction to 26\nsubdomains, which could be avoided by a more elegant solution.", 
            "title": "Meshing Components"
        }, 
        {
            "location": "/components/mesher/#meshing-components-in-gssf", 
            "text": "These wrap the two primary meshing tools in GSSF:  mesher-cgal  and GMSH . This gives rise to two (current) subclasses of GoSmartMesher , each providing a component class:  3D-CGAL  and 2D-GMSH . The specific type of component is specified using\nthe  type  parameter in the XML.  While most applications will use a single volumetric mesh, in certain cases it\nmay be necessary to use more than one mesh. Both (or more) will then be\navailable to the SIF template. Particular applications are: a highly detailed\nvolumetric mesh geometrically embedded in a simplified outer mesh; an\naxisymmetric mesh representing a portion of a larger Cartesian problem.  At least at present, meshing components are expected to output an MSH file. This\nmakes linkage more straightforward to the  ElmerGrid  component.", 
            "title": "Meshing Components in GSSF"
        }, 
        {
            "location": "/components/mesher/#configuration", 
            "text": "The relevant second-level element in GSSF-XML is:       mesher [ skip= SKIP:false  ] type= (CGAL|axisymmetric) \n        [  inner type= (CGAL|axisymmetric)  name= INNERNAME  template= TEMPLATE \n                 [ region= INNERREGION  ] [ needle= (inner_only|outer_only|both):both  ] \n               !-- see CGAL/axisymmetric-specific sections -- \n           /inner  ]\n           !-- see CGAL/axisymmetric-specific sections -- \n     /mesher   As a workaround for incomplete re-use of existing 2D meshes,  SKIP  may be outer  instead of a boolean, to re-use an existing primary 3D mesh, but\nregenerate any inner (usu. 2D) meshes. In the case that there are no inner\nmeshes (most cases), this is equivalent to  true .  The  inner  parameter  template , allows you to specify the template used for\nthe inner mesh - this is normally an axisymmetric needle geometry from the GSSF\nlibrary. The  needle  attribute allows you to indicate in which mesh the needle\nshould be embedded, (although axisymmetric templates may not always adjust for\nthis parameter). The  INNERREGION  allows you to specify a  region \nthat should form an outer boundary for the inner mesh - this is currently implemented\nonly in the case of volumetric meshes, but strictly it could be extended to both.  TODO : Allow user-supplied inner templates. Account for multiple needles when\nusing inner meshes.", 
            "title": "Configuration"
        }, 
        {
            "location": "/components/mesher/#3d-cgal", 
            "text": "This is a component wrapping  mesher-cgal .  Configuration  This is configured, extending the  mesher  or  inner  sections, as follows:      mesher|inner zone_boundaries= BOOL:false \n      !-- as in general configuration then -- \n        lengthscales nearfield= NF  farfield= FF  [ zonefield= ZF:(float|'ignore')  ]\n                     [ needlezonefield= NZF  ] [ granularity= GRANULARITY:float  ]\n                     [ vessels= (near|far)  ] [ needles= near  ] [ zones= solid  ]\n                     [ zone_radius= ZONERADIUS:float  ] / \n     (  extent radius= EXTENTRADIUS  /  |  extent region= REGIONNAME  /  )\n     [  centre x= CX  y= CY  z= CZ  radius= CR  /  ]\n        zone|needle region= REGIONNAME  [ characteristic_length= ZCL  ] [ priority= ZP  ] \n         [  activity x= AX  y= AY  z= AZ  r= AR  /  ]\n        /zone|needle \n       ...\n     [  organ region= REGIONNAME /  ]\n        surface region= REGIONNAME / \n       ...\n    /mesher|inner   The  surface  is any boundary region (was previously  vessel ) and requires only\nthe name of the  region  as expressed in the  regions  section. All\nglobal discretization information is contained in the lengthscales tag, which\nprovides parameters for the characteristic length field. The  extent  may be\nsupplied as a radius about the  centre  or as a region. The  organ , which is\nintersected with the  extent , may be supplied separately as a region. Needles,\nif simply surfaces, only need a  REGIONNAME  but if a zone, or both, may use the\nextended zone attribute set.  Zones have, at least, a  REGIONNAME  but they may also have their own\ncharacteristic length field and priority, which indicates which zones obscure\nwhich in an overlap. Optionally, there may be a child  activity  node,\nspecifying a sphere of activity. The inactive region will be added as a new\nregion to the global regions map.", 
            "title": "3D-CGAL"
        }, 
        {
            "location": "/components/mesher/#2d-gmsh", 
            "text": "GMSH  is used to mesh 2D domains, primarily for use in\naxisymmetric problems.  Configuration  This is configured, extending the  mesher  or  inner  sections, as follows:      mesher|inner \n      !-- as in general configuration then -- \n      template name= TEMPLATENAME  height= HEIGHT  width= WIDTH \n         dimension name= DIMENSIONNAME  value= DIMENSIONVALUE:float  / \n      /template \n      lengthscales nearfield= NEARFIELD  farfield= FARFIELD  / \n    /mesher|inner   The  TEMPLATENAME  parameter indicates a library template to use (effectively a\nGMSH  .geo  template). The template may use  $CONSTANT_XYZ  to refer to\ndimension  XYZ  and  $INNERHEIGHT  or  $INNERWIDTH  to refer to  HEIGHT  or WIDTH , respectively. It may use  $NEARFIELD  and  $FARFIELD  to get the NEARFIELD  and  FARFIELD  parameters, which should together be sufficient to\nset the characteristic lengths for GMSH. The template also has access to the region  IDs, which is prior to renumbering, but allows multiple\nmesher components to number consistently. These use the same constant naming\nscheme as the  Elmer  SIF template ( REGION_ORGAN , etc.). To parse\nthe template, string.Template \nis used.  TODO : Confirm this has no axisymmetric-specific behaviour and rename it to\nGMSH. Add support for supplied (non-library) templates.", 
            "title": "2D-GMSH"
        }, 
        {
            "location": "/components/mesher/#renumbering", 
            "text": "For Elmer to process a SIF file, numbering of bodies (volumetric subdomains)\nmust be contiguous. We use a application-level routine, GSSF.renumber_bodies(msh_files) , to achieve this,\nafter all other preliminary steps have been performed and we know exactly\nwhich subdomains appear in the simulation mesh. After this, ElmerGrid  is applied to convert to Elmer's meshing format. The output of\nthis step, not itself a full component, is in  meshes-reordered/ . Other than\nnumbering, these meshes should match those output by the optimizer in  optimizer/ .  TODO : to renumber in two steps, the mesh indices are temporarily replaced with\ncharacters using an ASCII mapping. This creates an artifical restriction to 26\nsubdomains, which could be avoided by a more elegant solution.", 
            "title": "Renumbering"
        }, 
        {
            "location": "/components/optimizer/", 
            "text": "Optimizer GSSF Component\n\n\nThis is an extremely basic component, wrapping \nGMSH\n for mesh optimization.\n\n\nConfiguration\n\n\nThe second-level \nGSSF-XML\n element is as follows:\n\n\n   \noptimizer [ method=\n(gmsh|netgen):gmsh\n ] /\n\n\n\n\n\nThe \nmethod\n corresponds to either the \n-optimize\n or \n-optimize_netgen\n\noptimization flag of GMSH.", 
            "title": "Optimizer Component"
        }, 
        {
            "location": "/components/optimizer/#optimizer-gssf-component", 
            "text": "This is an extremely basic component, wrapping  GMSH  for mesh optimization.", 
            "title": "Optimizer GSSF Component"
        }, 
        {
            "location": "/components/optimizer/#configuration", 
            "text": "The second-level  GSSF-XML  element is as follows:      optimizer [ method= (gmsh|netgen):gmsh  ] /   The  method  corresponds to either the  -optimize  or  -optimize_netgen \noptimization flag of GMSH.", 
            "title": "Configuration"
        }, 
        {
            "location": "/components/elmergrid/", 
            "text": "ElmerGrid GSSF Component\n\n\nElmerGrid\n is a tool in\nthe Elmer suite for converting meshes from non-Elmer formats to formats suitable\nfor the Elmer solver. It is capable of performing some other manipulations also,\nand is generally used for scaling the meshes to metres prior to simulation.\n\n\nThe current implementation always adds a \n-removeunused\n flag. If the\nsimulation will use \nNP\n multiple processes, \n-metis NP\n is appended, and\n\n-scale X\n if some global scaling is required. Note that the scaling for the\nsimulation, from the original input mesh length-scale, normally takes place in\nthis component.\n\n\nConfiguration\n\n\nThe ElmerGrid component is configured through an \nelmergrid\n node in the\nGSSF-XML, as a first-level child.\n\n\nelmergrid [ scale=\"X Y Z\" ] [ skip=\"SKIP_ELMERGRID:false\" ]\n\n\n/elmergrid\n\n\n\n\nIf \nsimulationscaling\n constant is set globally and the \nscale\n attribute is\nnot provided, it will be used to set ElmerGrid scaling.\n\n\nNotes\n\n\n\n\nAs the total simulation scaling is based on the scaling from the \nNeedle\nLibrary\n and ElmerGrid components, they should appear in that\norder in the XML, for the moment. In general, order should be irrelevant (FIXME)", 
            "title": "ElmerGrid Component"
        }, 
        {
            "location": "/components/elmergrid/#elmergrid-gssf-component", 
            "text": "ElmerGrid  is a tool in\nthe Elmer suite for converting meshes from non-Elmer formats to formats suitable\nfor the Elmer solver. It is capable of performing some other manipulations also,\nand is generally used for scaling the meshes to metres prior to simulation.  The current implementation always adds a  -removeunused  flag. If the\nsimulation will use  NP  multiple processes,  -metis NP  is appended, and -scale X  if some global scaling is required. Note that the scaling for the\nsimulation, from the original input mesh length-scale, normally takes place in\nthis component.", 
            "title": "ElmerGrid GSSF Component"
        }, 
        {
            "location": "/components/elmergrid/#configuration", 
            "text": "The ElmerGrid component is configured through an  elmergrid  node in the\nGSSF-XML, as a first-level child.  elmergrid [ scale=\"X Y Z\" ] [ skip=\"SKIP_ELMERGRID:false\" ]  /elmergrid   If  simulationscaling  constant is set globally and the  scale  attribute is\nnot provided, it will be used to set ElmerGrid scaling.", 
            "title": "Configuration"
        }, 
        {
            "location": "/components/elmergrid/#notes", 
            "text": "As the total simulation scaling is based on the scaling from the  Needle\nLibrary  and ElmerGrid components, they should appear in that\norder in the XML, for the moment. In general, order should be irrelevant (FIXME)", 
            "title": "Notes"
        }, 
        {
            "location": "/components/elmer/", 
            "text": "ElmerSolver GSSF Component\n\n\nElmerSolver\n is the\nsimulation tool within the Elmer suite. This GSSF component prepares\nconfiguration for it based on the GSSF-XML input, runs it and monitors it for\npercentage progress.\n\n\nElmer SIF template\n\n\nThe Elmer SIF provides the configuration of the solver. It is generated from\na \nJinja2\n template, which is supplied in the GSSF-XML.\nParameter dictionaries provide access to the global GSSF parameter list\nfrom the template - see \nConstants (Parameters)\n for more detail.\n\n\nIn addition to the global parameter dictionary, \np\n, and the dictionary of\nneedle parameter dictionaries \nneedles\n, there is a counter dictionary, \nc\n. It may used\nin a similar fashion to the parameter dictionaries, by member syntax. If a\nmember \nc.BODY\n, say, has not been used before, its first usage will return \n1\n.\nThe second will return \n2\n and so forth. Prefixing the member with an\nunderscore, \nc._BODY\n will return the current index without incrementing.\n\n\nNote that, while the GSSA simulation server scrubs SIF files, GSSF itself does\nnot. As such, if running GSSF separately \nyou should only accept SIF templates from trusted sources\n,\nSpecifically, several MATC functions provide access to the filesystem or printf,\nso precautions should be taken.\n\n\nAlgorithms\n in MATC will be written to a file with a unique\nID. A line sourcing it will be added at the end of the SIF, and the constant\nrepresenting the result, will be substituted with a call to it. For instance,\n\nElectric conductivity = {{ p.ELECTRIC_CONDUCTIVITY }}\n, when with an algorithm\nwith result \nELECTRIC_CONDUCTIVITY\n based on Argument \nTemperature\n is provided,\nwould become:\n\n\nElectric conductivity = Variable Temperature\n    Real MATC \"ELECTRIC_CONDUCTIVITY(tx(0))\"\n\n\n\nThe following filters are available, in addition to basic Jinja2 sandbox\nfilters:\n\n\n\n\n\n\n\n\nFilter name\n\n\nApply to\n\n\nPurpose\n\n\nParameters\n\n\n\n\n\n\n\n\n\n\ntyped\n\n\nParameter\n\n\nrender parameter with SIF type prefix\n\n\n-\n\n\n\n\n\n\ntotyped\n\n\nany Parameter-wrappable value\n\n\nrender value with SIF type prefix based on type \nd\n\n\nd\n (desired type)\n\n\n\n\n\n\ndiscretize\n\n\nnumber\n\n\nround to nearest \nr\n (returns int if \nr\n \n= 1)\n\n\nr\n (granularity)\n\n\n\n\n\n\n\n\nThe following global functions are available, in addition to basic Jinja2\nsandbox globals:\n\n\n\n\n\n\n\n\nFunction\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nzip\n\n\nas usu.\n\n\nPython built-in\n\n\n\n\n\n\nlist\n\n\nas usu.\n\n\nPython built-in\n\n\n\n\n\n\nmap\n\n\nas usu.\n\n\nPython built-in\n\n\n\n\n\n\nstr\n\n\nas usu.\n\n\nPython built-in\n\n\n\n\n\n\nneedle_distance\n\n\nneedle1id\n,\nneedle2id\n,\n(opt) \nd\n,\n(opt) \nref\n\n\nreturns the perpendicular distance between \nneedle1\n and \nneedle2\n, optionally starting from \nd\n metres (or simulation scale) along shaft from tip of needle \nref\n (\nneedle1id\n or \nneedle2id\n)\n\n\n\n\n\n\n\n\nTIP\n: Elmer tends to die without reporting an error if there is a problem with a MATC function,\nsometimes with a segfault or an unpredictable number output. If you notice you\nare getting simulations failing at the solver step, it is recommended that you\nrun \nElmerSolver_mpi\n manually in the \nelmer\n folder to see\nwhether this is the case. If so, removing and progressively adding in MATC\nfunctions should clarify which is causing the problem.\n\n\nStatus updates\n\n\nThe solver module starts a socket listening on \npercentage.sock\n in the simulation\ndirectory. An Elmer solver (\nNumaProgress\n) is available to connect to and update this based on\nthe solver \nPercentage Progress\n value. By adding this solver into your SIF file\nand setting \nPercentage Progress\n within it, you can receive percentage updates in the main\nPython process.\n\n\nTODO: Add in user-configurable status text, after checking for security\nissues that may rise.\n\n\nRuntime compilation\n\n\nModels can be tagged with certain library Fortran modules, which are then used\nin the SIF file as user-defined functions (UDFs). For security reasons, only\npredefined modules are available, such as \nmwa_RelPerm\n or \nmwa_ElecCond\n, which\nprovide temperature-dependent relative permittivity and electric conductivity\nfor microwave ablation. These modules can contain GSSF constants, which are\ninserted before compilation. They must be cast to numeric types only to\nprevent injection and it is recommended that any new modules are used only in\nstandalone mode with trusted template input.\n\n\nIn general, it is recommended to avoid this method\nas it is harder to abstract and errors in adding modules can compromise security,\nat least until GSSF is reorganised for use inside\nthe Docker workflow and sandboxing allows for user-supplied routines.\n\n\nPoint source location factories\n\n\nFor the point source models, where a series of heating points defines the input\npower distribution, a factory is used to simplify setting of models. The factory\ncan output locations at various probe extensions without these needing to be\npre-calculated on the client-side, or in the CDM. For this to work correctly, at\nleast in the current version, there must only be one needle present in a\nsimulation at a time. If needed, a workaround may be to add additional heating\npoints for a secondary needle to the first, provided all extension lengths and\ntimes match.\n\n\nSeveral probe location factories are contained in the GSSF codebase. These may\nbe extended by subclassing \nGoSmartElmerProbeLocationFactory\n and adding to\nthe dictionary, \ngssf.elmer_probelocation.probe_location_factories\n.\n\n\nA number of thermocouples may be defined, which can be used to label each of the\nheating points. These are passed to the actual solver and,\nnormally, used to switch points on and off according to some thermocouple-based\nalgorithm. The remaining points are split between \nends\n and \nmiddles\n,\nwhich are generally used to distribute power between two different levels by\nthe simulation module.\n\n\nThe default factories are outlined below.\n\n\nManual Probe Location Factory\n\n\nGoSmartElmerProbeLocationFactoryManual\n is selected by setting the point\nsources \nsystem\n to \nmanual\n. This requires all points to be configured for\nGSSF-XML and assumes a single extension.\n\n\nThe \npointsources\n XML block should be formatted as follows:\n\n\npointsources system=\"manual\"\n\n  [(\n    \nends|middles|thermocouples\n\n      \nlocation x=\"X1\" y=\"Y1\" z=\"Z1\" t=\"T1\" /\n\n      ...\n    \n/ends|middles|thermocouples\n\n  |\n    \nends|middles|thermocouples input=\"block\"\n\n        X1  Y1  Z1  T1 (tabbed)\n      ...\n    \n/ends|middles|thermocouples\n\n  )]*\n\n/pointsources\n\n\n\n\nwhere \nT\n, an integer, is the index of the controlling thermocouple in the\nlist of point sources.\n\n\nStraight Tines Location Factory\n\n\nGoSmartElmerProbeLocationFactoryStraightTines\n generates all point locations\nbased only on the shaft location and (scalar) extensions. It assumes the locus\nfrom shaft tip to the end of each of the tines is linear. Note that this does\nnot, strictly, equate to the tine itself being linear, but states that there\nshould be a \nmiddle\n heating point at the mid-point of a line from the shaft tip to each\n\nend\n point.\n\n\nThe \npointsources\n XML block should be formatted as follows:\n\n\npointsources system=\"straight tines\" [ offset=\"X Y Z\" ]\n\n  \nextensions\n\n    \nextension phase=\"0\" length=\"L1\"/\n\n    \nextension phase=\"1\" length=\"L2\"/\n\n    ...\n  \n/extensions\n\n\n/pointsources\n\n\n\n\nThe \noffset\n parameter allows the user to change the point location relative to\nthe needle-shaft tip. The shaft location is taken from the geometry section.\n\nLn\n lengths should be provided in metres.\nNote that the change of phase over time is usually controlled via a simulation module.\n\n\nUmbrella Tines Location Factory\n\n\nGoSmartElmerProbeLocationFactoryUmbrellaTines\n provides an arched configuration\nof heating points, where the \nend\n is perpendicular to the tip and the \nmiddle\n\nis at an angle beyond the tip, such that opposing tines form an M shape.\n\n\nConfiguration is identical to the \nStraight Tines Location\nFactory\n, using \nsystem=\"umbrella tines\"\n.\n\n\nExtrapolated Tine Factory\n\n\nGoSmartElmerProbeLocationFactoryExtrapolated\n takes the tip locations for the\nlargest extension and scales accordingly for other extensions. Note that\nclinicians generally do imaging showing full extension before starting the\nprotocol (at least, in radiofrequency ablation), so this location information is\navailable at the beginning of the procedure.\n\n\nThe \npointsources\n XML block should be formatted as follows:\n\n\npointsources system=\"extrapolated\" [ offset=\"X Y Z\" ]\n\n  \nextensions\n\n    \nextension phase=\"0\" length=\"L1\"/\n\n    \nextension phase=\"1\" length=\"L2\"/\n\n    ...\n  \n/extensions\n\n  \npoints\n\n    \npoint i=\"1\" x=\"X1\" y=\"Y1\" z=\"Z1\"/\n\n    \npoint i=\"2\" x=\"X2\" y=\"Y2\" z=\"Z2\"/\n\n    ...\n  \n/points\n\n\n/pointsources\n\n\n\n\nConfiguration\n\n\nThe XML format for the \nelmer\n first-level configuration node is as follows:\n\n\nelmer [ skip=\"SKIP_ELMER:false\" ]\n\n    [ \nrestart time=\"RESTART_TIME\" position=\"RESTART_INDEX\" old=\"PREVIOUS_SIF_PREFIX\" /\n ]\n    [ \npointsources system=\"TINE_FACTORY\"\n\n        \n!-- AS DEFINED ABOVE --\n\n      \n/pointsources\n ]\n    (\n      \nvariant [ modules=\"f90module1; f90module2;...\" ] name=\"SIF_TEMPLATE_LIBRARY_NAME\" /\n\n    |\n      \nvariant [ modules=\"f90module1; f90module2;...\" ] \n\n        ! SIF TEMPLATE\n        !\n        ...\n      \n/variant\n\n    )\n    [ \nsettings\n\n        \nsetting|constant name=\"non-slug setting name\" value=\"CONSTANT_VALUE\" type=\"CONSTANT_TYPE\" /\n\n        ...\n      \n/settings\n ]\n    [ \nalgorithms\n\n        \nalgorithm\n\n            \narguments\n\n              \nargument name=\"ARGUMENT_NAME\" /\n\n            \n/arguments\n\n            \ncontent\n\n              \n!-- Algorithm content - usu. MATC --\n\n            \n/content\n\n        \n/algorithm\n\n        ...\n      \n/algorithms\n ]\n\n/elmer\n\n\n\n\nNote that \nnon-slug setting name\n will translate to\n\nSETTING_NON_SLUG_SETTING_NAME\n in the SIF parameter dictionary.", 
            "title": "ElmerSolver Component"
        }, 
        {
            "location": "/components/elmer/#elmersolver-gssf-component", 
            "text": "ElmerSolver  is the\nsimulation tool within the Elmer suite. This GSSF component prepares\nconfiguration for it based on the GSSF-XML input, runs it and monitors it for\npercentage progress.", 
            "title": "ElmerSolver GSSF Component"
        }, 
        {
            "location": "/components/elmer/#elmer-sif-template", 
            "text": "The Elmer SIF provides the configuration of the solver. It is generated from\na  Jinja2  template, which is supplied in the GSSF-XML.\nParameter dictionaries provide access to the global GSSF parameter list\nfrom the template - see  Constants (Parameters)  for more detail.  In addition to the global parameter dictionary,  p , and the dictionary of\nneedle parameter dictionaries  needles , there is a counter dictionary,  c . It may used\nin a similar fashion to the parameter dictionaries, by member syntax. If a\nmember  c.BODY , say, has not been used before, its first usage will return  1 .\nThe second will return  2  and so forth. Prefixing the member with an\nunderscore,  c._BODY  will return the current index without incrementing.  Note that, while the GSSA simulation server scrubs SIF files, GSSF itself does\nnot. As such, if running GSSF separately  you should only accept SIF templates from trusted sources ,\nSpecifically, several MATC functions provide access to the filesystem or printf,\nso precautions should be taken.  Algorithms  in MATC will be written to a file with a unique\nID. A line sourcing it will be added at the end of the SIF, and the constant\nrepresenting the result, will be substituted with a call to it. For instance, Electric conductivity = {{ p.ELECTRIC_CONDUCTIVITY }} , when with an algorithm\nwith result  ELECTRIC_CONDUCTIVITY  based on Argument  Temperature  is provided,\nwould become:  Electric conductivity = Variable Temperature\n    Real MATC \"ELECTRIC_CONDUCTIVITY(tx(0))\"  The following filters are available, in addition to basic Jinja2 sandbox\nfilters:     Filter name  Apply to  Purpose  Parameters      typed  Parameter  render parameter with SIF type prefix  -    totyped  any Parameter-wrappable value  render value with SIF type prefix based on type  d  d  (desired type)    discretize  number  round to nearest  r  (returns int if  r   = 1)  r  (granularity)     The following global functions are available, in addition to basic Jinja2\nsandbox globals:     Function  Arguments  Description      zip  as usu.  Python built-in    list  as usu.  Python built-in    map  as usu.  Python built-in    str  as usu.  Python built-in    needle_distance  needle1id , needle2id , (opt)  d , (opt)  ref  returns the perpendicular distance between  needle1  and  needle2 , optionally starting from  d  metres (or simulation scale) along shaft from tip of needle  ref  ( needle1id  or  needle2id )     TIP : Elmer tends to die without reporting an error if there is a problem with a MATC function,\nsometimes with a segfault or an unpredictable number output. If you notice you\nare getting simulations failing at the solver step, it is recommended that you\nrun  ElmerSolver_mpi  manually in the  elmer  folder to see\nwhether this is the case. If so, removing and progressively adding in MATC\nfunctions should clarify which is causing the problem.", 
            "title": "Elmer SIF template"
        }, 
        {
            "location": "/components/elmer/#status-updates", 
            "text": "The solver module starts a socket listening on  percentage.sock  in the simulation\ndirectory. An Elmer solver ( NumaProgress ) is available to connect to and update this based on\nthe solver  Percentage Progress  value. By adding this solver into your SIF file\nand setting  Percentage Progress  within it, you can receive percentage updates in the main\nPython process.  TODO: Add in user-configurable status text, after checking for security\nissues that may rise.", 
            "title": "Status updates"
        }, 
        {
            "location": "/components/elmer/#runtime-compilation", 
            "text": "Models can be tagged with certain library Fortran modules, which are then used\nin the SIF file as user-defined functions (UDFs). For security reasons, only\npredefined modules are available, such as  mwa_RelPerm  or  mwa_ElecCond , which\nprovide temperature-dependent relative permittivity and electric conductivity\nfor microwave ablation. These modules can contain GSSF constants, which are\ninserted before compilation. They must be cast to numeric types only to\nprevent injection and it is recommended that any new modules are used only in\nstandalone mode with trusted template input.  In general, it is recommended to avoid this method\nas it is harder to abstract and errors in adding modules can compromise security,\nat least until GSSF is reorganised for use inside\nthe Docker workflow and sandboxing allows for user-supplied routines.", 
            "title": "Runtime compilation"
        }, 
        {
            "location": "/components/elmer/#point-source-location-factories", 
            "text": "For the point source models, where a series of heating points defines the input\npower distribution, a factory is used to simplify setting of models. The factory\ncan output locations at various probe extensions without these needing to be\npre-calculated on the client-side, or in the CDM. For this to work correctly, at\nleast in the current version, there must only be one needle present in a\nsimulation at a time. If needed, a workaround may be to add additional heating\npoints for a secondary needle to the first, provided all extension lengths and\ntimes match.  Several probe location factories are contained in the GSSF codebase. These may\nbe extended by subclassing  GoSmartElmerProbeLocationFactory  and adding to\nthe dictionary,  gssf.elmer_probelocation.probe_location_factories .  A number of thermocouples may be defined, which can be used to label each of the\nheating points. These are passed to the actual solver and,\nnormally, used to switch points on and off according to some thermocouple-based\nalgorithm. The remaining points are split between  ends  and  middles ,\nwhich are generally used to distribute power between two different levels by\nthe simulation module.  The default factories are outlined below.  Manual Probe Location Factory  GoSmartElmerProbeLocationFactoryManual  is selected by setting the point\nsources  system  to  manual . This requires all points to be configured for\nGSSF-XML and assumes a single extension.  The  pointsources  XML block should be formatted as follows:  pointsources system=\"manual\" \n  [(\n     ends|middles|thermocouples \n       location x=\"X1\" y=\"Y1\" z=\"Z1\" t=\"T1\" / \n      ...\n     /ends|middles|thermocouples \n  |\n     ends|middles|thermocouples input=\"block\" \n        X1  Y1  Z1  T1 (tabbed)\n      ...\n     /ends|middles|thermocouples \n  )]* /pointsources   where  T , an integer, is the index of the controlling thermocouple in the\nlist of point sources.  Straight Tines Location Factory  GoSmartElmerProbeLocationFactoryStraightTines  generates all point locations\nbased only on the shaft location and (scalar) extensions. It assumes the locus\nfrom shaft tip to the end of each of the tines is linear. Note that this does\nnot, strictly, equate to the tine itself being linear, but states that there\nshould be a  middle  heating point at the mid-point of a line from the shaft tip to each end  point.  The  pointsources  XML block should be formatted as follows:  pointsources system=\"straight tines\" [ offset=\"X Y Z\" ] \n   extensions \n     extension phase=\"0\" length=\"L1\"/ \n     extension phase=\"1\" length=\"L2\"/ \n    ...\n   /extensions  /pointsources   The  offset  parameter allows the user to change the point location relative to\nthe needle-shaft tip. The shaft location is taken from the geometry section. Ln  lengths should be provided in metres.\nNote that the change of phase over time is usually controlled via a simulation module.  Umbrella Tines Location Factory  GoSmartElmerProbeLocationFactoryUmbrellaTines  provides an arched configuration\nof heating points, where the  end  is perpendicular to the tip and the  middle \nis at an angle beyond the tip, such that opposing tines form an M shape.  Configuration is identical to the  Straight Tines Location\nFactory , using  system=\"umbrella tines\" .  Extrapolated Tine Factory  GoSmartElmerProbeLocationFactoryExtrapolated  takes the tip locations for the\nlargest extension and scales accordingly for other extensions. Note that\nclinicians generally do imaging showing full extension before starting the\nprotocol (at least, in radiofrequency ablation), so this location information is\navailable at the beginning of the procedure.  The  pointsources  XML block should be formatted as follows:  pointsources system=\"extrapolated\" [ offset=\"X Y Z\" ] \n   extensions \n     extension phase=\"0\" length=\"L1\"/ \n     extension phase=\"1\" length=\"L2\"/ \n    ...\n   /extensions \n   points \n     point i=\"1\" x=\"X1\" y=\"Y1\" z=\"Z1\"/ \n     point i=\"2\" x=\"X2\" y=\"Y2\" z=\"Z2\"/ \n    ...\n   /points  /pointsources", 
            "title": "Point source location factories"
        }, 
        {
            "location": "/components/elmer/#configuration", 
            "text": "The XML format for the  elmer  first-level configuration node is as follows:  elmer [ skip=\"SKIP_ELMER:false\" ] \n    [  restart time=\"RESTART_TIME\" position=\"RESTART_INDEX\" old=\"PREVIOUS_SIF_PREFIX\" /  ]\n    [  pointsources system=\"TINE_FACTORY\" \n         !-- AS DEFINED ABOVE -- \n       /pointsources  ]\n    (\n       variant [ modules=\"f90module1; f90module2;...\" ] name=\"SIF_TEMPLATE_LIBRARY_NAME\" / \n    |\n       variant [ modules=\"f90module1; f90module2;...\" ]  \n        ! SIF TEMPLATE\n        !\n        ...\n       /variant \n    )\n    [  settings \n         setting|constant name=\"non-slug setting name\" value=\"CONSTANT_VALUE\" type=\"CONSTANT_TYPE\" / \n        ...\n       /settings  ]\n    [  algorithms \n         algorithm \n             arguments \n               argument name=\"ARGUMENT_NAME\" / \n             /arguments \n             content \n               !-- Algorithm content - usu. MATC -- \n             /content \n         /algorithm \n        ...\n       /algorithms  ] /elmer   Note that  non-slug setting name  will translate to SETTING_NON_SLUG_SETTING_NAME  in the SIF parameter dictionary.", 
            "title": "Configuration"
        }, 
        {
            "location": "/components/lesion/", 
            "text": "Lesion-Extracting GSSF Component\n\n\nThis component wraps a separate tool, \ngo-smart-lesion\n, which uses\n\nVTK\n routines to extract a lesion surface. More generally,\nthis component extracts an isosurface based on certain criteria.\n\n\nConfiguration\n\n\nWhen running \ngo-smart-lesion\n as part of the GSSF workflow, the Python component can be configured as follows:\n\n\n    \nlesion field=\nFIELD\n\n            [ threshold_lower=\nTHRESHOLDLOWER\n ] [ threshold_upper=\nTHRESHOLDUPPER\n ] \n            [ selection=\n(most-recent|largest-time):most-recent\n ]\n            [ connectivity=\nBOOL:false\n ]\n            [ scaling=\nFLOAT\n ] /\n\n\n\n\n\nIf \nscaling\n is omitted, the inverse of\n\nsimulationscaling\n is used. This returns the simulation\nto the original, input length scale. If \nconnectivity\n is \ntrue\n, the largest\ncomponent only will be extracted. To choose a specific simulation timeslice for\ninput, the \nselection\n attribute can be set to either \nmost-recent\n, for the\nmost recently modified file in the \nElmer\n output directory, or\n\nlargest-time\n to choose the timeslice with the highest timestep suffix. On a\nclean run, these should pick the same output VTU file. The \nTHRESHOLDUPPER\n and\n\nTHRESHOLDLOWER\n values, if provided, will be used in a VTK \nThresholdBetween\n\ncall. If only one is provided, \nThresholdUpper\n or \nThresholdLower\n will be\nused. Note that this is the reverse of the VTK definition - we treat\n\nTHRESHOLDUPPER\n as the maximum accepted value within the lesion, and\n\nTHRESHOLDLOWER\n as the minimum. \nFIELD\n should be a field present in the VTU\nfile, which should correspond to variables output from the SIF template. Note\nthat Elmer seems to lowercase variable names before output, so \nFIELD\n should\nalso be lowercase even if the SIF template uses mixed/uppercase.\n\n\ngo-smart-lesion\n\n\ngo-smart-lesion\n may be run standalone from the shell. If so, the syntax is as follows:\n\n\ngo-smart-lesion OPTIONS\n\n\n\nOptional arguments\n\n\n\n\n\n\n\n\nArgument\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n-h [ --help ]\n\n\nproduce help message\n\n\n\n\n\n\n-t [ --threshold-lower ] arg\n\n\nthreshold for chosen variable (remove cells with values below this limit)\n\n\n\n\n\n\n-T [ --threshold-upper ] arg\n\n\nthreshold for chosen variable (remove cells with values above this limit)\n\n\n\n\n\n\n-S [ --scale ] arg (=1)\n\n\npre-scaling of results; default 1\n\n\n\n\n\n\n-f [ --field ] arg\n\n\nfield to threshold on\n\n\n\n\n\n\n-p [ --parallel ]\n\n\nassume input data is PVTU not VTU\n\n\n\n\n\n\n-x [ --threshold ]\n\n\nswitch from using an IsoVolume to using a Threshold\n\n\n\n\n\n\n-c [ --connectivity ]\n\n\nextract largest connected component of thresholded surface\n\n\n\n\n\n\n-s [ --subdivide ]\n\n\nsubdivide before thresholding\n\n\n\n\n\n\n-i [ --smoothing-iterations ] arg (=0)\n\n\nnumber of iterations in smoother (0 to skip)\n\n\n\n\n\n\n-e [ --exclude-subdomain ] arg (=-1)\n\n\nexclude subdomain of given index\n\n\n\n\n\n\n-i [ --input ] arg\n\n\ninput volume mesh file\n\n\n\n\n\n\n-a [ --analysis ] arg\n\n\nanalysis output file\n\n\n\n\n\n\n-o [ --output ] arg\n\n\noutput file\n\n\n\n\n\n\n-r [ --retain-subdomain-boundaries ]\n\n\nretain all internal inter-zone boundary facets\n\n\n\n\n\n\n-g [ --geometry-filter ]\n\n\nuse geometry filter instead of vtkDataSetSurfaceFilter to extract surface\n\n\n\n\n\n\n\n\nImplementation\n\n\nTODO-RMV: after refactoring", 
            "title": "Lesion Component"
        }, 
        {
            "location": "/components/lesion/#lesion-extracting-gssf-component", 
            "text": "This component wraps a separate tool,  go-smart-lesion , which uses VTK  routines to extract a lesion surface. More generally,\nthis component extracts an isosurface based on certain criteria.", 
            "title": "Lesion-Extracting GSSF Component"
        }, 
        {
            "location": "/components/lesion/#configuration", 
            "text": "When running  go-smart-lesion  as part of the GSSF workflow, the Python component can be configured as follows:       lesion field= FIELD \n            [ threshold_lower= THRESHOLDLOWER  ] [ threshold_upper= THRESHOLDUPPER  ] \n            [ selection= (most-recent|largest-time):most-recent  ]\n            [ connectivity= BOOL:false  ]\n            [ scaling= FLOAT  ] /   If  scaling  is omitted, the inverse of simulationscaling  is used. This returns the simulation\nto the original, input length scale. If  connectivity  is  true , the largest\ncomponent only will be extracted. To choose a specific simulation timeslice for\ninput, the  selection  attribute can be set to either  most-recent , for the\nmost recently modified file in the  Elmer  output directory, or largest-time  to choose the timeslice with the highest timestep suffix. On a\nclean run, these should pick the same output VTU file. The  THRESHOLDUPPER  and THRESHOLDLOWER  values, if provided, will be used in a VTK  ThresholdBetween \ncall. If only one is provided,  ThresholdUpper  or  ThresholdLower  will be\nused. Note that this is the reverse of the VTK definition - we treat THRESHOLDUPPER  as the maximum accepted value within the lesion, and THRESHOLDLOWER  as the minimum.  FIELD  should be a field present in the VTU\nfile, which should correspond to variables output from the SIF template. Note\nthat Elmer seems to lowercase variable names before output, so  FIELD  should\nalso be lowercase even if the SIF template uses mixed/uppercase.", 
            "title": "Configuration"
        }, 
        {
            "location": "/components/lesion/#go-smart-lesion", 
            "text": "go-smart-lesion  may be run standalone from the shell. If so, the syntax is as follows:  go-smart-lesion OPTIONS  Optional arguments     Argument  Description      -h [ --help ]  produce help message    -t [ --threshold-lower ] arg  threshold for chosen variable (remove cells with values below this limit)    -T [ --threshold-upper ] arg  threshold for chosen variable (remove cells with values above this limit)    -S [ --scale ] arg (=1)  pre-scaling of results; default 1    -f [ --field ] arg  field to threshold on    -p [ --parallel ]  assume input data is PVTU not VTU    -x [ --threshold ]  switch from using an IsoVolume to using a Threshold    -c [ --connectivity ]  extract largest connected component of thresholded surface    -s [ --subdivide ]  subdivide before thresholding    -i [ --smoothing-iterations ] arg (=0)  number of iterations in smoother (0 to skip)    -e [ --exclude-subdomain ] arg (=-1)  exclude subdomain of given index    -i [ --input ] arg  input volume mesh file    -a [ --analysis ] arg  analysis output file    -o [ --output ] arg  output file    -r [ --retain-subdomain-boundaries ]  retain all internal inter-zone boundary facets    -g [ --geometry-filter ]  use geometry filter instead of vtkDataSetSurfaceFilter to extract surface", 
            "title": "go-smart-lesion"
        }, 
        {
            "location": "/components/lesion/#implementation", 
            "text": "TODO-RMV: after refactoring", 
            "title": "Implementation"
        }, 
        {
            "location": "/components/validation/", 
            "text": "Go-Smart Simulation Framework - Validation Component\n\n\nThis component manages the validation step, comparing the output STL ablation\nlesion surface and a separately provided segmented validation STL surface.\n\n\nNote\n: this component is configured to wrap the (closed source) Aalto\nValidation Tool. For further details, please contact \nAalto\nUniversity\n.\n\n\nConfiguration\n\n\nThis tool is configured as follows:\n\n\n    \nvalidation reference=\nREFERENCEREGION\n [ registration=\nBOOL:true\n ] /\n\n\n\n\n\nThe \nREFERENCEREGION\n should be defined  in the \nregions\n section of\n\nGSSF-XML\n and provides the surface to which the lesion output by the\n\nlesion\n component will be compared. If \nregistration\n is \ntrue\n, the\ncomparison will be made after an error minimizing rigid transformation,\neffectively providing post-operative registration. If \nfalse\n, it assumes\nregistration of post- to pre-operative images has already occurred.", 
            "title": "Validation Component"
        }, 
        {
            "location": "/components/validation/#go-smart-simulation-framework-validation-component", 
            "text": "This component manages the validation step, comparing the output STL ablation\nlesion surface and a separately provided segmented validation STL surface.  Note : this component is configured to wrap the (closed source) Aalto\nValidation Tool. For further details, please contact  Aalto\nUniversity .", 
            "title": "Go-Smart Simulation Framework - Validation Component"
        }, 
        {
            "location": "/components/validation/#configuration", 
            "text": "This tool is configured as follows:       validation reference= REFERENCEREGION  [ registration= BOOL:true  ] /   The  REFERENCEREGION  should be defined  in the  regions  section of GSSF-XML  and provides the surface to which the lesion output by the lesion  component will be compared. If  registration  is  true , the\ncomparison will be made after an error minimizing rigid transformation,\neffectively providing post-operative registration. If  false , it assumes\nregistration of post- to pre-operative images has already occurred.", 
            "title": "Configuration"
        }, 
        {
            "location": "/tools/mesher-cgal/", 
            "text": "CGAL Meshing Utility - mesher-cgal\n\n\nUpstream contribution\n\n\nCertain minor modifications to the CGAL core may be desirable upstream,\nparticularly those relating to surface marking during volumetric meshing. Most\naspects of mesher-cgal are context-specific, so unlikely to be suitable for\ninclusion in the CGAL project, but may be of use to other downstream users,\nindependently.", 
            "title": "CGAL Meshing (mesher-cgal)"
        }, 
        {
            "location": "/tools/mesher-cgal/#cgal-meshing-utility-mesher-cgal", 
            "text": "", 
            "title": "CGAL Meshing Utility - mesher-cgal"
        }, 
        {
            "location": "/tools/mesher-cgal/#upstream-contribution", 
            "text": "Certain minor modifications to the CGAL core may be desirable upstream,\nparticularly those relating to surface marking during volumetric meshing. Most\naspects of mesher-cgal are context-specific, so unlikely to be suitable for\ninclusion in the CGAL project, but may be of use to other downstream users,\nindependently.", 
            "title": "Upstream contribution"
        }, 
        {
            "location": "/tools/numa-elmer/", 
            "text": "Extensions to the Elmer Project included in GSSF\n\n\nAs part of GSSF,\nwe have incorporated some minor alterations to the upstream solver, and\nadded a series of plug-in solver modules, to simplify GSSA integration or better\nsupport the ablation context.\n\n\nUpstream submission\n\n\nThe modifications to the upstream version of Elmer are branched from the\n\nGithub\n source tree to simplify\ncontribution. This is pending clarification of copyright assignment policy.", 
            "title": "Extensions to Elmer"
        }, 
        {
            "location": "/tools/numa-elmer/#extensions-to-the-elmer-project-included-in-gssf", 
            "text": "As part of GSSF,\nwe have incorporated some minor alterations to the upstream solver, and\nadded a series of plug-in solver modules, to simplify GSSA integration or better\nsupport the ablation context.", 
            "title": "Extensions to the Elmer Project included in GSSF"
        }, 
        {
            "location": "/tools/numa-elmer/#upstream-submission", 
            "text": "The modifications to the upstream version of Elmer are branched from the Github  source tree to simplify\ncontribution. This is pending clarification of copyright assignment policy.", 
            "title": "Upstream submission"
        }
    ]
}